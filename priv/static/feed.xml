<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://clutterstack.com/</id>
  <updated>2025-05-20T04:12:17.646626Z</updated>
  <title>Clutterstack</title>
  <link rel="self" href="https://clutterstack.com/feed.xml"/>
  <author>
    <name>Chris Nicoll</name>
  </author>
  <entry>
    <id>https://clutterstack.com/posts/2025-05-20-session-affinity/</id>
    <title>Session affinity with LiveView and Fly Machines</title>
    <updated>2025-05-20T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-05-20-session-affinity/"/>
    <content type="html"><![CDATA[<h2> Tedious backstory</h2> <p> I’ve been building an application to exercise some features of Phoenix/LiveView and Fly Machines.</p> <p> One of the main angles is this: you visit the app at <a href="https://where.fly.dev">https://where.fly.dev</a> and push the button. This triggers an API call requesting a new virtual machine on some Fly.io metal in the data centre nearest to you.</p> <aside class="sidenote rowspan-2 "> <p> Nearest the Fly.io edge server you hit using the app’s Anycast IP address, anyway. If your ISP and its BGP friends are having a bad day, your request could take the scenic route.</p> </aside> <p> When the server on this brand new VM is up and running, the LiveView redirects your browser to it. You see some slightly customised content, served by your very own Fly Machine. Said Machine proceeds to shut itself down and be destroyed forever.</p> <p> While the workload is entirely contrived, the whole schtick is compromised if I don’t ensure any button-pusher can interact only with the specific Machine they launched. In other words, I need session affinity, or sticky sessions.</p> <h2> The key to sticky sessions within a Fly <code class="inline">app</code> is <code class="inline">fly-replay</code></h2> <p> The Fly.io platform wants to let us model an <code class="inline">app</code> as instances of a service, or as a set of distinguishable VMs running in specific geographic locations, or both—whatever shape we want to build. From a networking point of view, the component that juggles these two ideas is fly-proxy (it’s what does load balancing; it’s in Rust; it has some neat tricks).</p> <aside class="sidenote rowspan-2 "> <p> There’s also IPv6 private networking, which is all, like, eBPF and WireGuard and Linux networking stuff on the VMs and physical hosts. It has tricks too, specifically some useful queries you can make on its internal DNS service, which the DNSCluster library uses for Erlang clustering.</p> </aside> <p> If you’re a visitor from the Internet via the app’s public URL (which resolves to an Anycast IP address), you hit an edge server and from there go where fly-proxy sends you. By default, that’s the Machine closest to you that has a service <a href="https://fly.io/docs/machines/api/machines-resource/#machine-config-object-properties">configured</a> on the requested port.</p> <p> Application code running on that closest Machine can change that destination, by sticking some rules inside a <code class="inline">fly-replay</code> custom header and tacking that on to its response. Instead of taking the response all the way back through the edge to the requestor, fly-proxy redelivers the original request to a Machine that fits the rules it finds in the <code class="inline">fly-replay</code> header.</p> <p> fly-proxy doesn’t remember <code class="inline">fly-replay</code>s of the past, so if I want a user to interact with exactly one specific Machine, all Machines running the same service have to meet every request with logic that deflects any other Machine’s rightful requests via <code class="inline">fly-replay</code>. </p> <aside class="sidenote rowspan-1 "> <p> There’s a new <a href="https://fly.io/docs/networking/dynamic-request-routing/#replay-caching">caching</a> feature for <code class="inline">fly-replay</code>, so now, in fact, it <em>can</em> remember—if what you want to cache is a replay rule for a wildcarded route.</p> </aside> <h2> An alternative to <code class="inline">fly-replay</code>: an <code class="inline">app</code> per “customer”</h2> <p> Here’s an alternative: putting each distinct Machine into its own Fly <code class="inline">app</code> with its own <code class="inline">.fly.dev</code> URL. </p> <p> For an ephemeral visitor experience, there are significant drawbacks to that approach: more API calls to execute and wait for; DNS setup and propagation; burning globally unique app names.</p> <aside class="sidenote rowspan-1 "> <p> You could make disposable app names pretty collision-proof, but it still seems stinky.</p> </aside> <p> If there were truly massive numbers of requests bouncing off the Wrong Machine in a serious application, it might be worth it, though.</p> <aside class="sidenote rowspan-2 "> <p> If the Machines don’t have to be directly reachable, but can pass data through an Internet-facing app, there are even more options using “6PN” private networking or Flycast.</p> </aside> <p> And for isolating workloads/users on their own VMs for security reasons, putting them into their own apps also lets you wall them off into separate <a href="https://fly.io/docs/networking/custom-private-networks/">custom IPv6 private networks</a>.</p> <p> I’m not worried about security here. For my purposes, <code class="inline">fly-replay</code> is a good solution. The chance of a visitor being connected to the wrong Machine is low in the first place, and there aren’t very many requests over a Machine’s lifetime; just something like the initial hit, some static assets, and a WebSocket upgrade.</p> <aside class="sidenote rowspan-4 "> <p> Between the brief lifetime of my Machines and fly-proxy bringing you to the one closest to you, there’s a pretty good chance no one would ever have noticed if I’d skipped session affinity altogether. </p> <p> In fact: for this particular example, I could re-use like one Machine and pretend it was a new one you started, and the experience would be pretty much identical as far as a visitor is concerned.</p> </aside> <p> So, on the Elixir, and especially the LiveView, side, how do I make it happen?</p> <h2> Peter Ullrich solved this exact thing already</h2> <p> As it happens, Peter Ullrich worked out exactly how to make sticky sessions work on Fly.io with a Phoenix/LiveView application, <a href="https://peterullrich.com/request-routing-and-sticky-sessions-in-phoenix-on-fly">and wrote it all out for us on his blog</a>. </p> <p> He wrote a Plug module that checks each incoming request for a query parameter, or failing that, a cookie, that matches the ID of the current Machine. If the query parameter matches, it puts that into a session cookie so that it’s passed in with all subsequent requests from that client (until that cookie gets changed). If there’s a parameter or a cookie, but it doesn’t match, the plug responds with a <code class="inline">fly-replay</code> header and a redirect status (307). </p> <aside class="sidenote "> <p> This 307 code is basically a placeholder. fly-proxy doesn’t care what status code or body you put on the response, and it doesn’t pass the response to the client (instead it waits to, hopefully, come back with the response that the target machine supplies).</p> </aside> <p> The tricky part is getting every request to go through that plug in a LiveView application. WebSocket connection requests don’t go through the Router, nor through the regular plugs in the Endpoint, so just adding a plug in either of those modules doesn’t cut it.</p> <p> To ensure everything, <em>everything</em>, goes through a particular plug, you can override the definition of the Endpoint’s <code class="inline">Plug.call/2</code> callback to run through that plug first. </p> <p> So the custom Plug module can check query parameters, check cookies, and compare the results with the current Machine’s ID. If they match, the <code class="inline">conn</code> gets dumped into the front end of the stock Endpoint to be handled in the usual way.</p> <p> It’s pretty neat, and Ullrich explains both the why and the how very nicely; you should go read his <a href="https://peterullrich.com/request-routing-and-sticky-sessions-in-phoenix-on-fly">original post</a>.</p> <h2> Oh hey, I’m still typing</h2> <p> Just so I can share my dumb mistake.</p> <p> When I first read Ullrich’s article, I refused to believe that my use case wasn’t simpler.</p> <p> I thought I should be able to simplify a normal LiveView authentication/authorization setup down to some path-based logic with a <a href="https://hexdocs.pm/phoenix_live_view/security-model.html#live_session"><code class="inline">live_session</code></a> and an <code class="inline">on_mount</code> hook to gate access to the LiveView and <code class="inline">fly-replay</code> any requests for a path indicating a different Machine.</p> <p> This almost worked! OK, no, not at all. There was a fundamental flaw. </p> <h2> If it weren’t for that pesky double-mount…</h2> <p> My <code class="inline">on_mount</code> hook can’t wrangle connections the way a plug can: it can’t send a <code class="inline">fly-replay</code> header. It can do a redirect to a route in the Router module, though. </p> <p> For a moment I thought it would be clever to get the <code class="inline">on_mount</code> callback to check the path against the <code class="inline">FLY_MACHINE_ID</code> environment variable (this part is fine) and if needed, cycle the connection back to the Router and through a plug, which <em>can</em> set headers and respond. </p> <p> If it’s not obvious, what this accomplishes when you hit the wrong Machine is an infinite loop of <code class="inline">fly-replay</code> “redirects”. Because getting the WebSocket connection up requires two mounts. The first mount catches the wrong Machine, and replays to the right Machine. </p> <p> But the WebSocket upgrade needs one more HTTP request, and this one doesn’t go through the Router. If fly-proxy thought the wrong Machine was a good choice the first time, it probably thinks the same thing this time too, and sends the upgrade request there, where the <code class="inline">on_mount</code> callback sends it back to the Router on the right Machine, where we start all over again.</p> <h2> Tweaks</h2> <p> I used <a href="https://peterullrich.com/request-routing-and-sticky-sessions-in-phoenix-on-fly">Ullrich’s solution</a> wholesale, with two functional adjustments to the plug:</p> <ul> <li> I added a condition to let requests to <code class="inline">/health</code> pass so that localhost can reach it (another plug in the router pipeline makes sure <em>only</em> localhost can, but also: it’s a boring route, and it doesn’t really matter if someone else reaches it). </li> <li> Instead of passing all connections that don’t match one of the conditions, I block them. There’s no resource that you should be looking for on this Machine if it’s not the Machine you created. </li> </ul> <p> See if it works for you at <a href="https://where.fly.dev">https://where.fly.dev</a>.</p> <p> My adaptation is in <a href="https://gist.github.com/clutterstack/97a66b4b7d7d82babf586962e80ade95">this gist</a>.</p>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2025-03-12-claude-scarily-good-faking-deterministic-output/</id>
    <title>Claude got scarily good at faking deterministic output</title>
    <updated>2025-03-12T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-03-12-claude-scarily-good-faking-deterministic-output/"/>
    <content type="html"><![CDATA[<p> The other day, I accidentally got Claude 3.7 Sonnet to generate a thousand-line, <a href="https://hexdocs.pm/req/">Req</a>-based Elixir API client from the <a href="https://docs.machines.dev/">OpenAPI spec for Fly Machines</a>.</p> <p> I was exploring the options for structuring such a module, more out of curiosity than any urgent need, and asked Claude on a whim if it could produce functions for all the endpoints. It did. Forty-odd functions, complete with typespecs and detailed docstrings. It hit its message-length limit and I had to ask it to carry on in a new message. It picked up and finished without incident. </p> <aside class="sidenote rowspan-2 "> <p> I have had zero previous success getting a complete response with the “continue” option in Claude chat. Admittedly it’s got to be trickier when the too-long message has interdependent functions that it has to reconcile.</p> </aside> <p> The output looks solid. It looks consistent. Claude doesn’t seem to have so much as supplemented the request parameters with a popular one from some other API.</p> <p> I was really impressed that Claude sustained such an uncanny impersonation of a dumb but reliable Python script for that long—despite the Vaudeville hook dragging it offstage partway through the act.</p> <aside class="sidenote rowspan-1 "> <p> Or <a href="https://github.com/OpenAPITools/openapi-generator/">Java program</a>.</p> </aside> <p> Also: this is terrible. Now I can sneeze and a nondeterministic black box barfs out a thousand lines of independent functions and docs oozing respectability and discipline? I’m going to be so tempted to trust this!</p> <p> If I’d planned an exhaustive client for this API, I’d have asked my machine buddy for help writing a boring Python script (or Mix task) to convert the OpenAPI spec directly, reproducibly, and with a lot less electricity.</p> <aside class="sidenote rowspan-1 "> <p> <a href="/posts/2024-10-24-llm-observations">Which is what I did</a> when I wanted <a href="https://hexdocs.pm/ecto/embedded-schemas.html">Ecto embedded schemas</a> to validate parameters going out in request bodies.</p> </aside> <p> I should note that the docstrings I ended up with are richer than what’s in the spec. Some of the example material identifiably originated in <a href="https://fly.io/docs/machines/api/">Fly.io developer docs</a>. So, there’s that.</p> <h2> Now that I have all that code</h2> <p> This may be the first time an LLM tool has bitten off more than <em>I</em> can chew without losing its own bearings. The vibes were practically telepathic.</p> <p> I don’t <em>approve</em> of using an LLM for tasks that need repeatability and can be done in seconds on a CPU. I can’t be sure there are no surprises until I’ve checked every function, and if I ask again, there’s no guarantee any deficiencies will be the same ones.</p> <p> But here’s the module, fully formed. What to do?</p> <p> I <em>do</em> want to talk to a subset of this API from my Elixir apps, and this gives me a starting point for incorporating the schema validation I’ve been playing with. </p> <p> I could “ship” it and fix it if I ever find out it’s broken—the stakes couldn’t be lower. But all those untried functions, all that unexamined documentation in my module—it was stressing me out.</p> <p> I took the easy way out: the reusable moving parts and a couple endpoint functions go into a module and the rest get banished into a slush file outside my project. I don’t have to look at them, but I can grab them as needed, if they ever are. Instant relief.</p> <aside class="sidenote rowspan-1 "> <p> The file’s called <code class="inline">jello.ex</code>. It’s tastier than slop and holds its shape better.</p> </aside> <h2> More things I think about LLMs, March 2025 edition</h2> <p> As always, the quality of the output of an LLM chat tool is entangled with the quality of my side of the conversation. It’s all moving targets and YMMV.</p> <ul> <li> The Elixir ecosystem abounds with high-signal, well-structured documentation. Claude’s grounding in Elixir has improved immensely in the past year. In my opinion, between the two we’ve hit a tipping point for a coding-while-learning momentum boost. </li> <li> Once the shiny, clean module appeared, I immediately got Claude to start messing it up by asking it a question about Req options. I think questions like “do I have to do X in order for Y to happen?” can be leading if there’s a weakness around Y in the model or the context. Claude is a bit too much of a people pleaser, and my lightweight attempts to counter that with project instructions and preferences haven’t cured that. </li> <li> It has happened, though, with both Claude and ChatGPT, that I’ve proposed one thing and the tool has correctly advised me to use a different approach. </li> <li> I do still wade into boggy ground with Claude 3.7, ask it to bite off more than it can chew and end up in a cycle of ineffectual “corrections”, or ask it something it doesn’t have a good grounding in and end up trying to find docs for nonexistent functions to help me implement some antipattern. </li> <li> At the end of February, I was surprised when Claude <em>3.5</em> Sonnet and I managed a very similar failure of attention navigating a bureaucracy of pattern-matching function heads. We both missed that the salient clause returned a value instead of handing it off to the next one in line. For all I know, this wouldn’t happen with 3.7. Claude can be so ultra-agreeable that I almost think I planted that blind spot by telling it what I couldn’t find. </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2025-02-27-iex-S-mix-phx-server/</id>
    <title>iex -S mix phx.server: What? How?</title>
    <updated>2025-02-27T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-02-27-iex-S-mix-phx-server/"/>
    <content type="html"><![CDATA[<p> <code class="inline">iex -S mix phx.server</code>: it starts up my Phoenix dev server under Elixir’s interactive shell program, <a href="https://hexdocs.pm/iex/IEx.html">IEx</a>, so I can call functions from my app and <a href="/posts/2025-01-30-observer-elixir">whatnot</a>.</p> <p> One day, it started to bug me <em>unreasonably</em> much that I didn’t really understand how this command causes that to happen. Perhaps culpable: a touch of delirium, downstream of the flu.</p> <p> There were a lot of reasons for my mystification (i.e. a lot of basic things I hadn’t thought much about before), so below you’ll find, if you want to, ~2700 words about some things that happen and how. I don’t expect even one whole person to read the entirety. It’s not that kind of blog post.</p> <p> There may be inaccuracies.</p> <h2> Interacting scripts</h2> <p> Before getting fancy, I want to know what my basic everyday Elixir commands do.</p> <p> The <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/elixir"><code class="inline">elixir</code></a>, <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/iex"><code class="inline">iex</code></a>, and <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/mix"><code class="inline">mix</code></a> commands are all scripts.</p> <aside class="sidenote rowspan-2 "> <p> I’m looking at the Unixy versions, but there are Windows <code class="inline">.bat</code> files too.</p> </aside> <h3> <code class="inline">elixir</code>, the script</h3> <p> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/elixir">The <code class="inline">elixir</code> shell script</a> constructs a string of arguments based on the arguments you supply, plus some information about your Elixir installation, and tacks that onto an <code class="inline">erl</code> command.</p> <aside class="sidenote rowspan-1 "> <p> The text for <code class="inline">elixir --help</code> comes from this file, too.</p> </aside> <div class="callout"> <p> <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html"><code class="inline">erl</code></a> comes with the Erlang distribution. It bootstraps an Erlang runtime environment, including starting a BEAM instance for everything to run on, and gets it to do the things indicated by the arguments. Unless you tell it not to, <code class="inline">erl</code> also supplies, and drops you into, the Erlang interactive shell.</p> </div> <aside class="sidenote "> <p> BEAM <a href="https://www.erlang.org/blog/beam-compiler-history/#beam-bogdans-erlang-abstract-machine">(Bogdan’s Erlang Abstract Machine)</a>: “the virtual machine that executes user code in the Erlang Runtime System (ERTS)” (John Högberg, <a href="https://www.erlang.org/blog/a-brief-beam-primer/"><em>A brief introduction to BEAM</em></a>)</p> </aside> <p> The <code class="inline">elixir</code> script ends with</p> <pre><code>if [ -n &quot;$ELIXIR_CLI_DRY_RUN&quot; ]; then echo &quot;$@&quot; else exec &quot;$@&quot; fi</code></pre> <p> It’s assembled the <code class="inline">erl</code> invocation, with all its arguments, into <code class="inline">&quot;$@&quot;</code>, and all that’s left is to execute that command. </p> <p> But look! By setting the <code class="inline">ELIXIR_CLI_DRY_RUN</code> env var, you can view the whole assembly instead of running it! I didn’t know that; I’m going to use it in a minute.</p> <h3> <code class="inline">mix</code>, the script</h3> <p> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/mix">The <code class="inline">mix</code> script</a> is exactly this:</p> <pre><code>#!/usr/bin/env elixir Mix.CLI.main()</code></pre> <aside class="sidenote rowspan-2 "> <p> <code class="inline">mix</code> help text comes from the <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/mix/lib/mix/cli.ex#L229"><code class="inline">display_usage/0</code></a> private function in <code class="inline">Mix.CLI</code>.</p> </aside> <p> This is an Elixir script! The shebang makes <code class="inline">mix</code> a (much) shorter way to write (in my case, with runtime installations managed by <a href="https://asdf-vm.com/">asdf</a>):</p> <pre><code class="sh">elixir /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/mix</code></pre> <p> So <code class="inline">mix</code> invokes <code class="inline">elixir</code> and we end up, again, with an <code class="inline">erl</code> command.</p> <p> This felt circular to me, because the <code class="inline">elixir</code> script doesn’t do anything with the contents of the <code class="inline">mix</code> script. But that’s just the way it works; rest assured that <em>something</em> eventually reads the file. We’ll see what, later.</p> <h3> <code class="inline">iex</code>, the script</h3> <p> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/iex">The <code class="inline">iex</code> shell script</a> ends with</p> <pre><code>exec &quot;$SCRIPT_PATH&quot;/elixir --no-halt --erl &quot;-user elixir&quot; +iex &quot;$@&quot;</code></pre> <p> Which is to say: it calls the <code class="inline">elixir</code> command with a specific set of arguments, followed by any arguments it was called with (<code class="inline">&quot;$@&quot;</code>). </p> <p> Another <code class="inline">erl</code> command.</p> <aside class="sidenote rowspan-2 "> <p> This explains why the help text for <code class="inline">iex</code>, for which this script happens to be the source, ends with this line: <code class="inline">It accepts all other options listed by &quot;elixir --help&quot;.</code> </p> <p> And it’s how we can use the <code class="inline">-S</code> flag with <code class="inline">iex</code>.</p> </aside> <p> <code class="inline">elixir --help</code> has entries for <code class="inline">--no-halt</code> (“[do] not halt the Erlang VM after execution”) and <code class="inline">--erl</code> (“[s]witches to be passed down to Erlang”). That <code class="inline">+iex</code> option isn’t in the help, but the <code class="inline">elixir</code> script does <a href="https://github.com/elixir-lang/elixir/blob/6ecb43061476c0870e24899a23ce8921835920d5/bin/elixir#L111">notice it</a>, and <a href="https://github.com/elixir-lang/elixir/blob/6ecb43061476c0870e24899a23ce8921835920d5/bin/elixir#L217">omit <code class="inline">-s elixir start_cli</code> from its <code class="inline">erl</code> arguments</a>. </p> <p> But we don’t have to work out the final set of arguments by reading the scripts. We can just print them out by setting the <code class="inline">ELIXIR_CLI_DRY_RUN</code> environment variable.</p> <h2> Pause to appreciate coolness</h2> <p> My Erlang/OTP installation doesn’t know anything about my Elixir installation.</p> <p> The arguments in these human-readable <code class="inline">erl</code> commands will have to tell it, or point it at, everything it needs to know in order to do whatever Elixir-land thing I wanted. This is not trivial or banal. It is very cool.</p> <h2> How to read <code class="inline">erl</code> arguments</h2> <p> So: <code class="inline">elixir</code> runs <code class="inline">erl</code> with a collection of arguments. And <code class="inline">iex</code> and <code class="inline">mix</code> both go through <code class="inline">elixir</code>. That is, each of these commands generates an <code class="inline">erl</code> command.</p> <aside class="sidenote "> <p> I neglected <a href="https://hexdocs.pm/elixir/modules-and-functions.html#compilation"><code class="inline">elixirc</code></a> but a quick check shows that <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/elixirc">it, too, calls <code class="inline">elixir</code></a>.</p> </aside> <p> The <code class="inline">erl</code> docs do a pretty good job of <a href="https://www.erlang.org/doc/apps/erts/erl_cmd#erl-arguments">explaining the different kinds</a> of argument that <code class="inline">erl</code> accepts, and what it does with each kind.</p> <p> It can be a bit hairy to categorise them in practice. The following paraphrases info that’s in the docs, with some emphasis on “subtleties” that I missed in my first reading, and that would have saved me some casting about in source code.</p> <ul> <li> <p> <a href="https://www.erlang.org/doc/apps/erts/erl_cmd#emu_flags"><strong>Emulator flags</strong></a> are for VM settings. Emulator flags start with a plus sign, <a href="https://www.erlang.org/doc/apps/erts/erl_cmd#erl-arguments">except when they start with a hyphen like all the other flags</a>. We won’t run into any emulator flags in this exercise. </p> </li> <li> <p> Many, but not all, <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">other defined flags</a> are marked as <strong>init flags</strong>: flags that are interpreted and used by Erlang’s <code class="inline">init</code> and not stored for later use. </p> </li> <li> <p> <code class="inline">--</code> and <code class="inline">-extra</code> are init flags that indicate that what follows is one or more <strong>plain_arguments</strong>: values that the <code class="inline">init</code> stores in a list that you can get later with <a href="https://www.erlang.org/doc/apps/erts/init.html#get_plain_arguments/0"><code class="inline">init:get_plain_arguments/0</code></a>. </p> </li> <li> <p> You, the user, can create <strong>user flags</strong> to suit your needs. The <code class="inline">init</code> stores user flags as key-value pairs, where the flag becomes an atom key for a value that’s a list of the items that follow (up until the next flag). To get this list, use <a href="https://www.erlang.org/doc/apps/erts/init.html#get_arguments/0"><code class="inline">init:get_arguments/0</code></a>. If an argument starts with a hyphen, and it’s not an init flag, an emulator flag or a plain argument, it’s a user flag. </p> </li> <li> <p> Some code that comes with the Erlang distribution looks for arguments stored with specific user flags. Some of these user flags are <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">documented alongside the init flags</a>. </p> </li> <li> <p> Case in point: there’s an important special-case user flag <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">documented</a> as <code class="inline">-Application Par Val</code>; when/if the OTP application named <code class="inline">Application</code> is started, <code class="inline">Application</code>‘s <code class="inline">Par</code> configuration option is set to <code class="inline">Val</code>. We see this shape of user flag in the <code class="inline">elixir</code> command. This one tripped me up; I could see the apparent intent but missed it in the docs. </p> </li> </ul> <h2> <code class="inline">elixir</code>, <code class="inline">mix</code>, <code class="inline">iex</code>: the <code class="inline">erl</code> angle</h2> <p> Armed with the above clues to how <code class="inline">erl</code> statements work, let’s look at minimal examples of each of our Elixir commands.</p> <h3> <code class="inline">elixir</code></h3> <p> If I don’t put something after <code class="inline">elixir</code>, it just prints its help at me, so I’ll tell it to print <code class="inline">hi</code> instead.</p> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 elixir -e &#39;IO.puts(&quot;hi&quot;)&#39;</code></pre> <p> Here’s what that spits out:</p> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -s elixir start_cli \ -extra -e IO.puts(&quot;hi&quot;)</code></pre> <p> That’s an eyeful, but it’s mostly because paths are long and messy. Flag by flag:</p> <dl> <dt> <p> <code class="inline">-noshell</code> </p> </dt> <dd> <p> Skips starting the Erlang shell. We want this init flag if we’re working in Elixir and not Erlang. Either we don’t want a shell, or we want IEx. </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib</code> </p> </dt> <dd> <p> <code class="inline">-elixir_root</code> is a user flag. We’re telling the <code class="inline">init</code> to store the path to our installed Elixir <code class="inline">lib</code> dir under the key <code class="inline">:elixir_root</code>. </p> <p> Spoiler: The <code class="inline">start/2</code> function of the <code class="inline">elixir</code> module <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L40">uses</a> this stored value to set paths to <code class="inline">ebin</code> directories, where <code class="inline">.beam</code> files are. </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin</code> </p> </dt> <dd> <p> <code class="inline">-pa</code> is an init flag. Adds the path to the Elixir <code class="inline">.beam</code> files to Erlang’s code path. </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-elixir ansi_enabled true</code> </p> </dt> <dd> <p> This is that special <code class="inline">-&lt;application&gt; &lt;parameter&gt; &lt;value&gt;</code> user-flag format. Sets <code class="inline">:ansi_enabled</code> to <code class="inline">true</code> in the <code class="inline">:elixir</code> OTP application’s config when it starts. </p> </dd> </dl> <aside class="sidenote "> <p> As it happens, if I omit <code class="inline">-elixir ansi_enabled true</code>, it still shows up in the configuration for the <code class="inline">elixir</code> application. To convince myself that I can affect the config (and getting a little ahead of the plot), I can start up a BEAM instance just to configure and start Elixir, print the configuration, and shut down:</p> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir cat_food kibble \ -s elixir start_cli \ -extra -e &quot;IO.inspect(Application.get_all_env(:elixir))&quot;</code></pre> <p> and find in the output</p> <pre><code class="sh">cat_food: :kibble, ansi_enabled: true</code></pre> </aside> <dl> <dt> <p> <code class="inline">-s elixir start_cli</code> </p> </dt> <dd> <p> <code class="inline">-s</code> is another init flag. Run function <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L194"><code class="inline">start_cli/0</code></a> of the <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl"><code class="inline">elixir</code> module</a>. </p> <p> This function starts the <code class="inline">elixir</code> OTP <a href="https://www.erlang.org/doc/apps/kernel/application">application</a> (and starts the <code class="inline">logger</code> application) and finally passes our list of stored plain arguments to <code class="inline">Elixir.Kernel.CLI.main/1</code>, <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L23">“the API invoked by [the] Elixir boot process”</a> with this line: </p> <pre><code class="erlang"> &#39;Elixir.Kernel.CLI&#39;:main(init:get_plain_arguments()).</code></pre> <p> (Good thing we told Erlang where to find Elixir with the <code class="inline">-pa</code> flag.) </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-extra -e IO.puts(&quot;hi&quot;)</code> </p> </dt> <dd> <p> Each thing after <code class="inline">-extra</code> in an <code class="inline">erl</code> expression is a plain argument, so <code class="inline">-e</code> and <code class="inline">&#39;IO.puts(&quot;hi&quot;)&#39;</code> are stored by the <code class="inline">init</code> as such. </p> <p> My <code class="inline">&#39;IO.puts(&quot;hi&quot;)&#39;</code> came out without its single quotes. I can roll with that; I had to type it in a way that would be parsed unambiguously in the shell, and now it’s in the shape it has to be in for the next thing to parse. </p> <p> On that topic, we can quickly check how the <code class="inline">init</code> stores plain arguments: </p> <pre><code class="sh">erl -extra -e &#39;IO.puts(&quot;hi&quot;)&#39; </code></pre> <pre><code>Erlang/OTP 27 [erts-15.2.1] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit] Eshell V15.2.1 (press Ctrl+G to abort, type help(). for help) 1&gt; init:get_plain_arguments(). [&quot;-e&quot;,&quot;IO.puts(\&quot;hi\&quot;)&quot;]</code></pre> <p> (Plain arguments keep their order in the list, which is important when it comes to parsing and using them.) </p> </dd> </dl> <p> Recapping what’s explicit in the <code class="inline">erl</code> expression: typing <code class="inline">elixir -e &#39;IO.puts(&quot;hi&quot;)&#39;</code> into my system shell starts an Erlang VM (BEAM) instance in which the Erlang <code class="inline">init</code> process:</p> <ul> <li> <em>doesn’t</em> start an Erlang shell </li> <li> prepares the Erlang runtime environment, including: <ul> <li> setting the path to Elixir <code class="inline">.beam</code> files </li> <li> storing some <code class="inline">arguments</code>, which in this case are for setting up the <code class="inline">elixir</code> OTP application </li> <li> storing some <code class="inline">plain_arguments</code> that correspond to the arguments I passed to the <code class="inline">elixir</code> command </li> </ul> </li> <li> invokes the <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L194"><code class="inline">start_cli/0</code></a> function of the <code class="inline">elixir</code> module </li> </ul> <p> That’s the end of what we can read on the face of the <code class="inline">erl</code> expression.</p> <p> Then, <code class="inline">elixir:start_cli/0</code> configures and starts the <code class="inline">elixir</code> and <code class="inline">logger</code> OTP applications, yoinks the list of plain arguments from the Erlang <code class="inline">init</code>, and passes that to our first Elixir function, <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex#L25"><code class="inline">Elixir.Kernel.CLI.main/1</code></a>. </p> <p> So I want to know what Elixir does with these arguments.</p> <div class="callout"> <h4> What Elixir does with the plain arguments</h4> <p> <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex#L25"><code class="inline">Elixir.Kernel.CLI.main/1</code></a> starts out with a <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex#L6">map of default config options</a> for its own internal use and the incoming <code class="inline">argv</code> list provided by <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L194"><code class="inline">elixir:start_cli/0</code></a>, and surfs <code class="inline">parse_argv/2</code> clauses, knocking arguments out of <code class="inline">argv</code> and modifying its <code class="inline">config</code> map as they match.</p> <p> The arguments must include something to run, or there’s no point to any of this. An argument preceded by a flag like <a href="https://github.com/elixir-lang/elixir/blob/69990a5d1d3cd00ed0422a87b49841c27e16ff15/lib/elixir/lib/kernel/cli.ex#L233"><code class="inline">&quot;-S&quot;</code></a> or <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L272"><code class="inline">&quot;-e&quot;</code></a>, or an argument that <a href="https://github.com/elixir-lang/elixir/blob/69990a5d1d3cd00ed0422a87b49841c27e16ff15/lib/elixir/lib/kernel/cli.ex#L381">hasn’t been otherwise recognised, and so is assumed to indicate a file</a>, is identified as a thing to run, and populates the <code class="inline">commands</code> list in the <code class="inline">config</code> map.</p> <p> What remains in <code class="inline">argv</code> once the <code class="inline">parse_argv</code> gauntlet is run <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L27">replaces</a> the <a href="https://hexdocs.pm/elixir/System.html"><code class="inline">System</code> “command line arguments” list</a> for whatever runs next, and <code class="inline">Kernel.CLI.main/1</code> turns its attention to executing its list of <code class="inline">commands</code>.</p> </div> <p> So <em>that’s</em> what <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L23">“the API invoked by [the] Elixir boot process”</a> meant. The options you pass to the <code class="inline">elixir</code> CLI command, telling it what you want “Elixir” to do, go to the <code class="inline">Kernel.CLI</code> Elixir module, which makes it happen.</p> <p> My request to <code class="inline">e</code>valuate the Elixir syntax <code class="inline">IO.puts(&quot;hi&quot;)</code> is executed. The VM prints <code class="inline">hi</code> to stdout. I see it in my terminal. Elixir has done what I asked and halts the system.</p> <h3> <code class="inline">mix</code></h3> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 mix </code></pre> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -s elixir start_cli \ -extra /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/mix</code></pre> <p> This is identical to the <code class="inline">elixir -e &#39;IO.puts(&quot;hi&quot;)&#39;</code> example, but with different plain arguments after the <code class="inline">-extra</code> flag.</p> <p> <code class="inline">Elixir.Kernel.CLI</code> will recognise the path to the <code class="inline">mix</code> script as the path to a file, read it, and call the function inside: <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/mix/lib/mix/cli.ex"><code class="inline">Mix.CLI.main()</code></a>.</p> <div class="callout"> <h3> By the way: these <code class="inline">erl</code> commands aren’t for us</h3> <p> Running <code class="inline">erl</code> commands from the shell does an end run around the Elixir installation and the environment setup it takes care of. </p> <p> It just so happens that I got away with running the simple <code class="inline">elixir</code> example by its <code class="inline">erl</code> equivalent, but trying the same with <code class="inline">mix</code> leaves me missing <code class="inline">MIX_HOME</code> and <code class="inline">MIX_ARCHIVES</code> environment variables, the initial symptom being that Mix doesn’t know where to find <a href="https://hex.pm/">Hex</a>. </p> </div> <h3> <code class="inline">iex</code></h3> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 iex </code></pre> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -user elixir \ -extra --no-halt +iex</code></pre> <p> In the not-IEx commands, <code class="inline">-s elixir start_cli</code> started Elixir, but the <code class="inline">-s</code> flag doesn’t show up here.</p> <dl> <dt> <p> <code class="inline">-user elixir</code> </p> </dt> <dd> <p> ELUSIVE. But important! <code class="inline">-user</code> is a user flag, and isn’t in the docs, but it’s a special one; the Erlang <code class="inline">user_sup</code> module <a href="https://github.com/erlang/otp/blob/maint-27/lib/kernel/src/user_sup.erl#L43">looks in the init arguments</a> for the key <code class="inline">user</code>. </p> <p> The <code class="inline">user</code> is the process that deals with the Erlang VM’s I/O; to interact with IEx, we need input and output to go through it. </p> <p> The best resource I’ve found for this Erlang <code class="inline">user</code> concept: <a href="https://ferd.ca/repl-a-bit-more-and-less-than-that.html"><em>REPL? A bit more (and less) than that</em></a> by Fred Hebert. (“If you want to change where the IO takes place, change the user process, and everything gets redirected.”) </p> <p> It looks like passing <code class="inline">-user elixir</code> means <a href="https://github.com/erlang/otp/blob/maint-27/lib/kernel/src/user_sup.erl#L102"><code class="inline">user_sup:start_user/3</code></a> calls <a href="https://www.erlang.org/doc/apps/erts/erlang#apply/3"><code class="inline">apply(elixir, start, [])</code></a>. </p> <p> In turn, <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L182"><code class="inline">elixir:start/0</code></a> passes <a href="https://github.com/erlang/otp/blob/b6ab3a385ec72e346a44807d53e2109a51cde613/lib/kernel/src/user_drv.erl#L145"><code class="inline">user_drv:start/2</code></a> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/iex.erl#L48"><code class="inline">iex:shell/0</code></a> for its <code class="inline">initial_shell</code> argument and <code class="inline">iex:shell/0</code>, finally, calls <code class="inline">elixir:start_cli/0</code>, which feeds our plain arguments to <code class="inline">Kernel.CLI</code> to be acted on. </p> </dd> </dl> <aside class="sidenote rowspan-2 "> <p> The name of the <a href="https://hexdocs.pm/iex/IEx.html#module-the-user-switch-command">User switch command</a> now makes a lot more sense to me.</p> <p> Possibly <code class="inline">-user</code> isn’t documented among <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">defined <code class="inline">erl</code> flags</a> because to use it you’d have to implement your own <code class="inline">user</code>, which would put you beyond needing to look up the flag…?</p> <p> A notable commit (2012): <a href="https://github.com/elixir-lang/elixir/commit/678fafe7c13b5950c770ad16d77622a7d0ebc0f0">“Improve IEx by using the -user option (ht @yrashk)”</a></p> </aside> <dl> <dt> <p> <code class="inline">-extra --no-halt +iex</code> </p> </dt> <dd> <p> The plain arguments are <code class="inline">--no-halt</code> and <code class="inline">+iex</code>. </p> <p> We can find their significance in the Elixir <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex"><code class="inline">Kernel.CLI</code> source</a>: </p> <ul> <li> <code class="inline">--no-halt</code> results in a <code class="inline">no_halt: true</code> entry in the <code class="inline">config</code> map, which results in the decision not to emit <code class="inline">System.halt(status)</code> after executing <code class="inline">commands</code>. </li> <li> <code class="inline">+iex</code> sets <code class="inline">mode: :iex</code> in <code class="inline">config</code>; this seems to be mainly used to decide how to deal with other flags like <code class="inline">-v</code> or <code class="inline">--version</code>, and <code class="inline">--dbg</code>. </li> </ul> </dd> </dl> <p> Differences from the <code class="inline">elixir</code> command: </p> <ul> <li> start the <code class="inline">iex</code> application after <code class="inline">elixir</code> </li> <li> send all VM I/O through <code class="inline">iex</code> </li> <li> don’t halt the system once <code class="inline">Kernel.CLI</code> has processed the plain arguments and taken any actions they ask for </li> </ul> <aside class="sidenote "> <p> The <code class="inline">elixir</code> application <a href="https://github.com/elixir-lang/elixir/tree/v1.18/lib/elixir/src">source</a> is written Erlang; <code class="inline">iex</code> <a href="https://github.com/elixir-lang/elixir/tree/v1.18/lib/iex/lib">source</a> is in Elixir.</p> </aside> <p> As we know, the end result is that I’m dropped into an IEx shell once all that’s done, and I can ask IEx to run moar Elixir.</p> <h2> What’s running in the VM?</h2> <p> Bare minimum, that is.</p> <p> Here are the started applications in my bare IEX shell.</p> <pre><code class="sh">iex -e &quot;IO.inspect(Application.started_applications)&quot;</code></pre> <pre><code class="sh">Erlang/OTP 27 [erts-15.2.1] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit] [ {:logger, ~c&quot;logger&quot;, ~c&quot;1.17.3&quot;}, {:iex, ~c&quot;iex&quot;, ~c&quot;1.17.3&quot;}, {:elixir, ~c&quot;elixir&quot;, ~c&quot;1.17.3&quot;}, {:compiler, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;8.5.4&quot;}, {:stdlib, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;6.2&quot;}, {:kernel, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;10.2.1&quot;} ] Interactive Elixir (1.17.3) - press Ctrl+C to exit (type h() ENTER for help) iex(1)&gt; </code></pre> <p> I haven’t run into the place that starts the <code class="inline">compiler</code> application, but I can wave my hands and say it makes sense that we’d need it; I might ask the VM to run something that hasn’t been compiled yet.</p> <p> I can compare the applications started in a VM that I spun up to run an Elixir function to list the applications started in it:</p> <pre><code class="sh">elixir -e &quot;IO.inspect(Application.started_applications)&quot;</code></pre> <pre><code class="sh">[ {:logger, ~c&quot;logger&quot;, ~c&quot;1.17.3&quot;}, {:elixir, ~c&quot;elixir&quot;, ~c&quot;1.17.3&quot;}, {:compiler, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;8.5.4&quot;}, {:stdlib, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;6.2&quot;}, {:kernel, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;10.2&quot;} ]</code></pre> <p> For fun, here’s one just for <code class="inline">erl</code>. Just <code class="inline">kernel</code> and <code class="inline">stdlib</code> in this VM:</p> <pre><code class="sh">erl -eval &#39;io:format(&quot;~p~n&quot;, [application:which_applications()]).&#39;</code></pre> <aside class="sidenote rowspan-2 "> <p> I totally got Claude (3.7 Sonnet, 27 Feb 2025) to write this snippet.</p> </aside> <pre><code class="sh">Erlang/OTP 27 [erts-15.2.1] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit] [{stdlib,&quot;ERTS CXC 138 10&quot;,&quot;6.2&quot;},{kernel,&quot;ERTS CXC 138 10&quot;,&quot;10.2.1&quot;}] Eshell V15.2.1 (press Ctrl+G to abort, type help(). for help) 1&gt; </code></pre> <h2> Putting the pieces together</h2> <p> When we start the BEAM with an <code class="inline">iex</code> command, all the VM’s I/O goes through IEx, and IEx implements the interactivity, including taking care of interpretation of Elixir expressions, or compilation of code, as necessary.</p> <p> All that’s left is to add <code class="inline">-S mix phx.server</code>:</p> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 iex -S mix phx.server </code></pre> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -user elixir \ -extra --no-halt +iex -S mix phx.server</code></pre> <p> No surprises. Just like <code class="inline">iex</code>, but with an additional <code class="inline">-S mix phx.server</code> after <code class="inline">-extra</code>. </p> <p> Check on the plain arguments:</p> <pre><code class="sh">iex(1)&gt; :init.get_plain_arguments() [~c&quot;--no-halt&quot;, ~c&quot;+iex&quot;, ~c&quot;-S&quot;, ~c&quot;mix&quot;, ~c&quot;phx.server&quot;]</code></pre> <h3> How does Mix get its arguments?</h3> <p> We already talked about how the <code class="inline">[&quot;-S&quot;, &quot;mix&quot;]</code> part of the arguments list means <code class="inline">Elixir.Kernel.CLI</code> will execute the <code class="inline">mix</code> script. </p> <p> And we kinda know that Mix has to see the <code class="inline">&quot;phx.server&quot;</code> argument, since that’s the Mix Task we’re trying to run. Let’s just put a tidy bow on how that happens: </p> <p> As soon as <code class="inline">Kernel.CLI.parse_argv/2</code> matches <code class="inline">&quot;-S&quot;</code>, it stashes the next argument as a <code class="inline">:script</code> into its list of <code class="inline">commands</code> to run, and quits looking for things to parse. Everything that’s left in the original arguments list stays in the system command-line arguments list (<code class="inline">System.argv/0</code>). In this case, <code class="inline">&quot;phx.server&quot;</code> is what’s left.</p> <p> On the Mix side, the contents of the <code class="inline">mix</code> script calls <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/mix/lib/mix/cli.ex"><code class="inline">Mix.CLI.main/1</code></a>, which defaults to getting its argument list from <code class="inline">System.argv/0</code>. Voilà: <code class="inline">Mix.CLI.main([&quot;phx.server&quot;])</code>.</p> <aside class="sidenote "> <p> I just checked and I can start this blog’s dev server from an IEx prompt by typing exactly that: <code class="inline">Mix.CLI.main([&quot;phx.server&quot;])</code></p> </aside> <p> An analogous thing happens, also via <code class="inline">Kernel.CLI</code>, if we run <code class="inline">mix phx.server</code>, or <code class="inline">elixir -S mix phx.server</code>.</p> <p> The first thing that <code class="inline">Mix.CLI.main/1</code> does is start the Mix application with <a href="https://github.com/elixir-lang/elixir/blob/69990a5d1d3cd00ed0422a87b49841c27e16ff15/lib/mix/lib/mix.ex#L426"><code class="inline">Mix.start/0</code></a>—but I could go on like this forever. Let’s just agree that Mix is now going to run the <code class="inline">phx.server</code> task.</p> <h2> Why is it shaped like this?</h2> <p> I now <em>truly believe</em> that <code class="inline">iex -S mix phx.server</code> starts my Phoenix dev server on a fresh Erlang VM and drops me into an Elixir shell in that VM.</p> <p> I’ve had the chance to admire the effort and ingenuity that goes into letting users run programs—no—<em>start up VMs and</em> run programs on them—with simple one-liners. </p> <p> I still go back and forth between “this is an obvious command that’s really explicit about what it does” and “something about this feels magical and weird.” That <code class="inline">-S</code> just sits kinda funny.</p> <p> If I were in the habit of using <code class="inline">elixir -S mix phx.server</code> to run the <code class="inline">phx.server</code> Mix task (which works): look, symmetry! <code class="inline">iex -S mix phx.server</code> is the same thing but through IEx!</p> <p> But I don’t do that, because <code class="inline">mix phx.server</code> works, thanks to <code class="inline">mix</code> being an Elixir script you can also invoke from a system shell. It all makes sense! Not so symmetric, though.</p> <p> In the end, it’s a balance between elegance and power. I see a lot more elegance in it than I did before.</p> <h2> Trivia: Some history of <code class="inline">iex -S mix</code></h2> <p> Early on, it seems there was some tension between the conciseness of <code class="inline">mix iex</code> (possible when <code class="inline">mix</code> is a plain shell script) and the flexibility of <code class="inline">iex -S mix</code> (possible when <code class="inline">mix</code> is an Elixir script); <code class="inline">bin/mix</code> went back and forth between shell script and Elixir script in 2012-2013: </p> <aside class="sidenote "> <p> Hat tip to <a href="https://elixirforum.com/t/where-to-find-info-about-iex-s-mix-command/48045/4"><code class="inline">@adamu</code> on the Elixir Forum</a>.</p> </aside> <ul> <li> 2012/07/16: <a href="https://github.com/elixir-lang/elixir/commit/a5a2025daf54f4a414ebcc1ba9949b7832b1b12d">“Add mix file executables”</a> (a shell script) </li> <li> 2012/07/31: <a href="https://github.com/elixir-lang/elixir/commit/05e52f9437d692c4fc8dc1b731574bbeeadc6fc6">“Make mix an Elixir script”</a> (an Elixir script) </li> <li> 2012/11/30: <a href="https://github.com/elixir-lang/elixir/commit/b3d203712a82fb02fc39016e42deba145825a856">“Fix mix iex”</a> (a shell script again) </li> <li> 2012/12/05: J. Valim: “I believe we need to remove support for <code class="inline">mix iex</code> as it needs to be <code class="inline">iex -S mix</code>.” (<a href="https://github.com/elixir-lang/elixir/issues/692">v0.7.2 breaks mix #692</a>; some discussion here.) </li> <li> 2013/01/20: <a href="https://github.com/elixir-lang/elixir/commit/aa9c93305ec27fa22a81b46a92ac7c9a985a8b30">“Provide iex -S mix instead of mix iex”</a> (an Elixir script again) </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/lagan/resources-erlang-otp/</id>
    <title>Erlang and OTP resources</title>
    <updated>2025-02-22T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/lagan/resources-erlang-otp/"/>
    <content type="html"><![CDATA[<p> <a href="https://www.erlang.org/doc/readme.html">Erlang docs home</a></p> <p> <a href="https://www.erlang.org/doc/system/design_principles.html">OTP design principles</a> - Supervision trees, behaviours, applications, releases, release handling</p> <p> <a href="https://learnyousomeerlang.com/">Learn you some Erlang for great good</a> - the classic by Fred Hebert</p> <p> <a href="https://www.erlang.org/blog">The OTP team blog</a> - good resource on how some things work</p>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2025-01-30-observer-elixir/</id>
    <title>Running Observer in IEx alongside an Elixir app</title>
    <updated>2025-01-30T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-01-30-observer-elixir/"/>
    <content type="html"><![CDATA[<p> I wanted to try out Erlang’s <a href="https://www.erlang.org/doc/apps/observer/observer_ug.html">Observer</a> application to dig into the workings of my Elixir/Phoenix dev server. It didn’t immediately work, for two main reasons:</p> <ol> <li> Observer’s graphical interface depends on both the <a href="https://www.wxwidgets.org/">wxWidgets</a> cross-platform GUI library and the OTP application <a href="https://www.erlang.org/doc/apps/wx/chapter.html">wx</a>, which supplies Erlang bindings for it. My system had neither. </li> <li> Once I’d sorted out the system problems in 1., I was able to run Observer from a plain IEx prompt, but not from the prompt opened with <code class="inline">iex -S mix phx.server</code>. To understand this, I had to learn that Elixir “prunes unused code paths.” More about this later. </li> </ol> <p> Getting past these roadblocks turned out pretty straightforward with the latest Erlang/OTP and a newish Elixir on my M2 Macbook in January 2025. I say <em>turned out</em>, because past discussions on issues around asdf, Erlang and wxWidgets had me ready for a big mess, and it took me a bit to isolate what was relevant to me.</p> <aside class="sidenote "> <p> For example: <a href="https://github.com/asdf-vm/asdf-erlang/issues/319">A late-2024 issue and discussion on the <code class="inline">asdf-erlang</code> GitHub repo</a>; <a href="https://elixirforum.com/t/observer-in-iex-s-mix-error-undefinedfunctionerror-function-wx-object-start-3-is-undefined/58544">a 2023-2024 topic on the Elixir Forum</a>.</p> <p> It’s possible that some of the complications folks have brought up with XCode or <code class="inline">ulimit</code> are still relevant; they just didn’t come up for me.</p> </aside> <p> Incidentally, I think everything here also applies to Erlang’s <a href="https://www.erlang.org/doc/apps/debugger/debugger_chapter.html">debugger</a> application, which also uses wxWidgets.</p> <h2> Sorting out my system</h2> <h3> Install wxWidgets</h3> <p> To begin with, I didn’t even have wxWidgets installed on my computer. I installed it with Homebrew: </p> <pre><code class="bash">brew install wxwidgets</code></pre> <h3> Install Erlang with wx enabled</h3> <p> I was still missing the <a href="https://www.erlang.org/doc/apps/wx/chapter.html">wx</a> OTP application; it had been disabled in my existing Erlang installation.</p> <p> I manage runtimes on my Mac with <a href="https://asdf-vm.com/guide/introduction.html">asdf</a>. I suspect that I could have simply uninstalled and reinstalled Erlang after putting wxWidgets on my system, but I included wx explicitly, as follows:</p> <pre><code class="sh">export KERL_CONFIGURE_OPTIONS=&quot;--with-wx&quot; asdf install erlang 27.2</code></pre> <aside class="sidenote rowspan-2 "> <p> The <a href="https://github.com/asdf-vm/asdf-erlang">asdf Erlang plugin</a> uses <a href="https://github.com/kerl/kerl"><code class="inline">kerl</code></a> to build Erlang. Setting the <code class="inline">KERL_CONFIGURE_OPTIONS</code> environment variable to <code class="inline">&quot;--with-wx&quot;</code> makes sure <code class="inline">kerl</code> includes wx.</p> </aside> <p> The conservative thing would have been to uninstall the current Erlang and reinstall the same version but with wx enabled, but I went ahead and updated from 26.0.1 to 27.2. </p> <p> Because I changed versions, I put the correct version in my project’s <a href="https://asdf-vm.com/manage/configuration.html#tool-versions"><code class="inline">.tool-versions</code></a> file with <a href="https://asdf-vm.com/guide/getting-started.html#local"><code class="inline">asdf local</code></a>. Because I changed <em>major</em> versions, I also had to install an Elixir compiled with the right Erlang/OTP, and set the local version of that as well.</p> <aside class="sidenote "> <p> Related: <a href="2025-01-29-asdf-switch-erlang">My personal cheat sheet for the mechanics of changing Erlang versions with asdf</a></p> </aside> <h3> Check that wx and Observer work</h3> <p> At this point I was able to fire up IEx with <code class="inline">iex</code> and type </p> <pre><code class="makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="nc">:observer</span><span class="o">.</span><span class="n">start</span><span class="p" data-group-id="8578840674-1">(</span><span class="p" data-group-id="8578840674-1">)</span></code></pre> <p> and the Observer GUI popped up. Under the Applications tab were listed just <code class="inline">elixir</code>, <code class="inline">iex</code>, <code class="inline">kernel</code>, and <code class="inline">logger</code>.</p> <p> There’s also the <a href="https://www.erlang.org/doc/apps/wx/wx.html#demo/0">wx demo</a>. Since I’d seen Observer working in IEx, I didn’t need to check wx by itself, but it’s a thing if you do need it or want to try it. Start up the Erlang shell:</p> <pre><code class="sh">erl</code></pre> <p> And run the demo:</p> <pre><code class="erlang">&gt; wx:demo().</code></pre> <p> A demo GUI should open, proving that wxWidgets and its Erlang bindings are present and working.</p> <h2> The deal with code-path pruning</h2> <p> <a href="https://elixirforum.com/t/elixir-v1-15-0-released/56584">As of Elixir 1.15, before a Mix project gets compiled, “unused code paths” are pruned</a>, including for applications that ship with Elixir or Erlang, like Observer. </p> <p> Translation: the Erlang runtime will look for modules in only directories containing the project’s dependencies. This makes compilation faster.</p> <p> So, a general-purpose IEx prompt has access to all the stuff that comes with your Elixir and Erlang installations, but use <code class="inline">iex -S</code> to run a Mix task, and any module that is not used in that Mix project becomes invisible.</p> <h3> Including Observer and its dependencies</h3> <p> You can declare a dependency on an OTP application in <code class="inline">mix.exs</code> by <a href="https://hexdocs.pm/mix/1.18.2/Mix.Tasks.Compile.App.html">including it in an <code class="inline">application/0</code> function, under <code class="inline">:extra_applications</code></a>. My understanding is that this is meant for applications shipped with Erlang/OTP or Elixir—everything else you’d just put in your <code class="inline">deps</code> definition. </p> <aside class="sidenote rowspan-1 "> <p> Trivia: according to its <a href="https://hexdocs.pm/mix/1.18.2/Mix.Tasks.Compile.App.html">documentation</a>, Mix makes sure applications in <code class="inline">:extra_applications</code> are started before the project application—with the exception of applications declared <code class="inline">:optional</code>. </p> </aside> <p> If you don’t always need a given application in the project, you can instead make it available from the prompt on a one-off basis. Without putting anything into my <code class="inline">:extra_applications</code>, under OTP 27, I can start my dev server: </p> <pre><code class="sh">iex -S mix phx.server</code></pre> <p> Then restore the code path to Observer in IEX with <a href="https://hexdocs.pm/mix/1.18.2/Mix.html#ensure_application!/1"><code class="inline">Mix.ensure_application!(app)</code></a>:</p> <pre><code class="makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="nc">Mix</span><span class="o">.</span><span class="n">ensure_application!</span><span class="p" data-group-id="2459944102-1">(</span><span class="ss">:observer</span><span class="p" data-group-id="2459944102-1">)</span></code></pre> <aside class="sidenote "> <p> It seems that <code class="inline">Mix.ensure_application!/1</code> goes ahead and pulls in an application’s optional dependencies in a way that adding it to <code class="inline">:extra_applications</code> doesn’t:</p> <blockquote> <p> You need to add <code class="inline">:wx</code> to extra applications because it is an optional dependency of <code class="inline">:observer</code>. The <code class="inline">ensure_application!</code> also considers optional dependencies. </p> <p> – <em><a href="https://elixirforum.com/t/observer-in-iex-s-mix-error-undefinedfunctionerror-function-wx-object-start-3-is-undefined/58544/10">José Valim on the Elixir Forum</a></em> </p> </blockquote> </aside> <p> Finally, start Observer:</p> <pre><code class="makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="nc">:observer</span><span class="o">.</span><span class="n">start</span><span class="p" data-group-id="3898366742-1">(</span><span class="p" data-group-id="3898366742-1">)</span></code></pre> <p> Up pops the Observer GUI. A quick check of the Applications tab shows the application supervision tree for my running project. </p> <h2> Other notes</h2> <p> It looks like the way dependencies, and thus “unused code paths” to be pruned, are decided has been streamlined between OTP 26 and OTP 27.</p> <p> Under Erlang/OTP 26, I had to explicitly require <code class="inline">:wx</code> and <code class="inline">:runtime_tools</code> as well as <code class="inline">:observer</code> in order to run Observer. With OTP 27 I only had to ensure <code class="inline">:observer</code>, even after removing the <code class="inline">:extra_applications</code> keyword entirely from the <code class="inline">application</code> definition in my <code class="inline">mix.exs</code>. </p> <p> I see that <code class="inline">:observer_backend</code> is part of <code class="inline">:runtime_tools</code>. I’m keeping that in mind in case I need to understand this when I try to look at production nodes from my laptop.</p>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/elixir/2025-01-29-asdf-switch-erlang/</id>
    <title>Switching an Elixir project between Erlang/OTP major versions with asdf</title>
    <updated>2025-01-29T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/elixir/2025-01-29-asdf-switch-erlang/"/>
    <content type="html"><![CDATA[<h2> Assumptions</h2> <p> We manage runtimes with <a href="https://asdf-vm.com">asdf</a>. In this example we’re using Elixir 1.17.3 in a project and want to switch from <a href="https://github.com/erlang/otp">OTP</a> 26.2.5.6 to OTP 27.2.</p> <h2> Steps</h2> <h3> 0. Check the status quo</h3> <p> See which versions of any installed runtimes, including Elixir and Erlang/OTP, are set for the current directory, and see if that’s through the global <code class="inline">.tool-versions</code> config file or a local one:</p> <pre><code class="sh">asdf current</code></pre> <p> See which versions of Erlang/OTP are installed on the system with asdf:</p> <pre><code class="sh">asdf list elixir</code></pre> <pre><code class="sh">asdf list erlang</code></pre> <h3> 1. Install the new Erlang/OTP</h3> <pre><code class="sh">asdf install erlang 27.2</code></pre> <h3> 2. Install an Elixir version compiled with the right OTP major version</h3> <p> Even if we don’t want to upgrade Elixir versions per se, we do need to match the Elixir installation with our OTP major version.</p> <pre><code class="sh">asdf install elixir 1.17.3-otp-27 </code></pre> <h3> 3. Set the project to use the newly installed versions of both</h3> <pre><code class="sh">asdf local elixir 1.17.3-otp-27</code></pre> <pre><code class="sh">asdf local erlang 27.2</code></pre> <p> Now asdf is configured to point to the newly installed version of Erlang/OTP and the Elixir version that’s compatible with it. </p> <aside class="sidenote "> <p> You can edit <code class="inline">.tool-versions</code> directly, but If you don’t know which version you need, <code class="inline">asdf local</code> (and <code class="inline">asdf global</code>) conveniently shows you the possible versions if you hit the <code class="inline">tab</code> key.</p> </aside> <h2> References</h2> <ul> <li> <a href="https://asdf-vm.com/guide/introduction.html">asdf guide introduction</a> </li> <li> <a href="https://asdf-vm.com/manage/configuration.html">asdf configuration (<code class="inline">.tool-versions</code>)</a> </li> <li> <a href="https://github.com/asdf-vm/asdf-erlang">asdf Erlang plugin</a> </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/lagan/2025-01-12-tailwind-wrong-way/</id>
    <title>Using Tailwind CSS the wrong way</title>
    <updated>2025-01-13T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/lagan/2025-01-12-tailwind-wrong-way/"/>
    <content type="html"><![CDATA[<p> I was in the midst of power-washing <a href="https://tailwindcss.com/">Tailwind</a> classes off of a Phoenix component (for reasons) when Xe Iaso posted this: <a href="https://xeiaso.net/blog/2025/tailwind-sans-bloat/">CSSWind: bloat-free component styling</a>. Here’s my (unironic) opportunistic tie-in.</p> <p> I’m persistently perturbed by HTML festooned with utility classes. But Tailwind presets tangibly save me typing time and decision-making time, and they’re easy to remember.</p> <aside class="sidenote rowspan-1 "> <p> Yay constraints!</p> </aside> <p> What I’ve found myself doing, increasingly, is giving elements more-or-less semantic classes and hiding the styling away in <code class="inline">.css</code> files where, also increasingly, I use Tailwind’s <code class="inline">@apply</code> directive to put Tailwind classes in place of CSS.</p> <p> It all comes out in the wash when Tailwind spits out a file full of regular CSS.</p> <p> <a href="https://tailwindcss.com/docs/reusing-styles">This would seem to be an official anti-pattern</a>, and I’ll entertain the thought that it may just be a stubborn lone-developer habit. I’m wearing my stubborn lone-developer hat at the moment, so until I grow out of it, I think it’s cool that Tailwind itself doesn’t judge me for it.</p> <aside class="sidenote rowspan-1 "> <p> I’ve decided to infer that though <em>people</em> may judge, Tailwind is tacitly cool with it because it doesn’t throw any speed bumps in my way.</p> </aside> <h2> An example</h2> <p> In:</p> <pre><code class="css">div.annotated-content-container { @apply grid grid-cols-[4fr_3fr] col-span-full rounded-lg mb-6 bg-zinc-100; background: linear-gradient(to right, rgba(241, 245, 249, 1) 57%, rgba(241, 245, 249, 0) 43%); } .annotated-content { @apply w-full items-start rounded-lg border border-slate-300 py-4; } .subgrid-holder { @apply grid grid-cols-subgrid col-span-full; }</code></pre> <p> Out:</p> <pre><code class="css">div.annotated-content-container { grid-column: 1 / -1; margin-bottom: 1.5rem; display: grid; grid-template-columns: 4fr 3fr; border-radius: 0.5rem; --tw-bg-opacity: 1; background-color: rgb(244 244 245 / var(--tw-bg-opacity)); background: linear-gradient(to right, rgba(241, 245, 249, 1) 57%, rgba(241, 245, 249, 0) 43%); } .annotated-content { width: 100%; align-items: flex-start; border-radius: 0.5rem; border-width: 1px; --tw-border-opacity: 1; border-color: rgb(203 213 225 / var(--tw-border-opacity)); padding-top: 1rem; padding-bottom: 1rem; } .subgrid-holder { grid-column: 1 / -1; display: grid; grid-template-columns: subgrid; }</code></pre> <aside class="sidenote "> <p> If I were really finicky about bloat (in my CSS) I’d find a way to process out the variables. Some Elixir in my project would likely beat PostCSS for convenience, since Phoenix’s very plush asset processing uses the standalone Tailwind binary. Related: <a href="https://github.com/tailwindlabs/tailwindcss/issues/15136">v4 larger base output #15136</a> </p> </aside>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/elixir/2024-12-31-js-in-phoenix/</id>
    <title>Adding custom JavaScript to a Phoenix app</title>
    <updated>2024-12-31T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/elixir/2024-12-31-js-in-phoenix/"/>
    <content type="html"><![CDATA[<p> Out of the box, the Phoenix <a href="https://hexdocs.pm/phoenix/asset_management.html">asset build system</a> bundles custom JS alongside default Phoenix JS dependencies, using <a href="https://esbuild.github.io/">esbuild</a>, into a script that the app serves with all its pages.</p> <aside class="sidenote rowspan-2 "> <p> CSS is dealt with in an analogous way, using <a href="https://tailwindcss.com/">tailwindcss</a>.</p> </aside> <p> I was braced for this to be much more complicated than it is.</p> <p> Basic usage is described in the comments at the top of <code class="inline">assets/js/app.js</code>. To paraphrase, with a little colour:</p> <ul> <li> The convention is to put source files for front-end assets into your app’s <a href="https://hexdocs.pm/phoenix/directory_structure.html#the-assets-directory"><code class="inline">assets</code> directory</a>. The suggested location for third-party JS files is <code class="inline">assets/vendor</code>, and for LiveView hooks it’s <code class="inline">assets/js/hooks</code>. </li> <li> In <code class="inline">assets/js/app.js</code>: <ul> <li> <code class="inline">import</code> the new JS files—or one file that <code class="inline">imports</code> its own dependencies. </li> <li> Add any calls to imported JS functions that should be executed when the browser loads a page. </li> </ul> </li> </ul> <p> When the project’s assets are built, esbuild bundles the contents of <code class="inline">assets/js/app.js</code> and its <code class="inline">import</code>ed dependencies (and their dependencies, recursively) into <code class="inline">priv/static/assets/app.js</code> where it’s available to be served as a static asset. </p> <p> Assets get built either by a watcher on the running dev server or by a Mix task. When the server starts in dev mode, it, in turn, starts an esbuild process in watch mode that builds and rebuilds the JS bundle as its source files change.</p> <p> The <code class="inline">assets.build</code> and <code class="inline">assets.deploy</code> <a href="https://hexdocs.pm/mix/Mix.html#module-aliases">Mix aliases</a> include an <code class="inline">esbuild</code> Mix task to build JS assets (<code class="inline">assets.deploy</code> minifies them as well).</p> <p> The bundled <code class="inline">priv/static/assets/app.js</code> is served at <code class="inline">/assets/app.js</code> and sourced in <code class="inline">&lt;script&gt;</code> tags in the app’s root layout, so that it runs when the browser loads a page.</p> <h2> Building blocks</h2> <p> Chris McCord’s <a href="https://gist.github.com/chrismccord/2ab350f154235ad4a4d0f4de6decba7b#migrate-to-esbuild-for-js-and-css-bundling-optional">gist on upgrading from Phoenix v1.5 to v1.6</a> illuminates the moving parts of the esbuild-based system that come with a freshly generated Phoenix app.</p> <h3> The esbuild Hex package</h3> <p> An <a href="https://github.com/phoenixframework/esbuild/">Elixir wrapper for esbuild</a> that provides the Esbuild module and Mix tasks to install and run esbuild.</p> <h3> config.exs</h3> <p> Contains a configuration entry for the esbuild wrapper, with a named <a href="https://github.com/phoenixframework/esbuild/tree/main?tab=readme-ov-file#profiles">execution profile</a> that gives a set of args and options common to all out-of-the-box esbuild invocations in the app.</p> <aside class="sidenote rowspan-2 "> <p> You can define multiple profiles if you want to generate different bundles.</p> </aside> <p> This profile sets <code class="inline">assets/js/app.js</code> as the entry point and <code class="inline">priv/static/assets</code> as the output directory to pass to esbuild.</p> <h3> mix.exs</h3> <p> Includes the <code class="inline">esbuild</code> Hex package in the project dependencies; it’s only part of the runtime in a development environment.</p> <p> Defines Mix <a href="https://hexdocs.pm/mix/Mix.html#module-aliases">aliases</a> <code class="inline">assets.build</code> and <code class="inline">assets.deploy</code> that run the <code class="inline">esbuild</code> Mix task with the execution profile from <code class="inline">config.exs</code>.</p> <h3> dev.exs</h3> <p> Contains the dev-environment-only configuration for the app’s <code class="inline">Endpoint</code> module. Configures a “watcher” that calls the <code class="inline">Esbuild.install_and_run</code> function to start esbuild, in watch mode, again with the profile defined in <code class="inline">config.exs</code>.</p> <aside class="sidenote rowspan-2 "> <p> <code class="inline">:watchers</code> is part of the app’s <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#module-runtime-configuration">Endpoint’s runtime configuration</a>. A watcher here is an executable that starts when the server starts—it’s a slightly misleading name because “watching” behaviour has to be supplied by the executable itself.</p> </aside> <h3> root.html.heex</h3> <p> The app’s root layout. Sources the bundled JS assets with <code class="inline">&lt;script&gt;</code> tags.</p> <h3> router.ex</h3> <p> Following this even further: the app’s Router module includes the <code class="inline">browser</code> pipeline, where the <code class="inline">put_root_layout</code> plug incorporates <code class="inline">root.html.heex</code>, and thus the app’s bundled <code class="inline">app.js</code>, into every page that gets piped through the <code class="inline">browser</code> pipeline.</p> <aside class="sidenote "> <p> Root layout: <code class="inline">lib/your_app_web/components/layouts/root.html.heex</code>. Embedded by the app’s <code class="inline">Layouts</code> module.</p> </aside> <h2> Or</h2> <p> Nothing stops you from adding your own <code class="inline">&lt;script&gt;</code> tags, in the app’s root layout or somewhere else, pointing to some script that a user’s browser can reach: a location on the net, or a file your app serves with a <code class="inline">Static</code> plug.</p> <p> Taking that further, you could tweak the out-of-the-box Phoenix asset management system to generate another custom bundle and reference that script from only certain layouts or pages.</p> <h2> References</h2> <ul> <li> <a href="https://hexdocs.pm/phoenix/asset_management.html#third-party-js-packages">Asset management: Third-party JS packages</a> (Phoenix docs) </li> <li> <a href="https://hexdocs.pm/phoenix/directory_structure.html#the-assets-directory">The assets directory</a> (Phoenix docs) </li> <li> <a href="https://gist.github.com/chrismccord/2ab350f154235ad4a4d0f4de6decba7b">Chris McCord’s gist on upgrading to Phoenix 1.6</a> (shows how to manually configure an app for esbuild instead of webpack) </li> <li> <a href="https://github.com/phoenixframework/esbuild/">Elixir wrapper for esbuild</a> (GitHub repo) </li> <li> <a href="https://hexdocs.pm/mix/Mix.html#module-aliases">Aliases</a> (Mix docs) </li> <li> <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#module-runtime-configuration">Phoenix.Endpoint module runtime configuration</a> (with watcher config) (Phoenix docs) </li> <li> <a href="https://hexdocs.pm/elixir/Config.html">Config API</a> (Elixir docs) </li> <li> <a href="https://hexdocs.pm/phoenix/Phoenix.Router.html#module-pipelines-and-plugs">Pipelines and plugs</a> (Phoenix docs) </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/elixir/2024-10-26-elixir-plug-static-paths/</id>
    <title>Custom paths for static assets in a Phoenix app</title>
    <updated>2024-10-26T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/elixir/2024-10-26-elixir-plug-static-paths/"/>
    <content type="html"><![CDATA[<p> TIL you can use multiple <a href="https://hexdocs.pm/plug/Plug.Static.html"><code class="inline">Static</code> plugs</a> to serve static files at custom paths in an Elixir / Phoenix app.</p> <p> I used this to specify the path at which my sitemap files are served without affecting any other static assets.</p> <p> In a project created with <code class="inline">mix phx.new</code>, the <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html">Endpoint</a> module sets out a initial plug pipeline that all requests go through. (It ends with <code class="inline">plug YourAppWeb.Router</code>, passing the request off to your app’s Phoenix <a href="https://hexdocs.pm/phoenix/Phoenix.Router.html">Router</a> module, which decides which pipeline it should go through next.)</p> <p> Requests pass through <a href="https://hexdocs.pm/plug/Plug.Static.html"><code class="inline">Plug.Static</code></a> early on; if the request path matches a path in the app’s <code class="inline">priv/static/</code> directory, it serves the file directly.</p> <p> Here’s mine:</p> <pre><code class="makeup elixir"><span class="w"> </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Static</span><span class="p">,</span><span class="w"> </span><span class="ss">at</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">from</span><span class="p">:</span><span class="w"> </span><span class="ss">:clutterstack</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="nc">ClutterstackWeb</span><span class="o">.</span><span class="n">static_paths</span><span class="p" data-group-id="2906793060-1">(</span><span class="p" data-group-id="2906793060-1">)</span></code></pre> <p> By default, everything in <code class="inline">priv/static/</code> is served at a URL that reflects the file’s path relative to that directory. The <code class="inline">only: YourAppWeb.static_paths()</code> option narrows that down to a list of folders and files.</p> <p> The <code class="inline">:only</code> option also saves unnecessary file system reads: the request URI is checked against this list first, so if the requested path isn’t included, there’s no need to check inside <code class="inline">priv/static/</code> for the presence of the file.</p> <p> For fun, let’s just look at where that list is defined. Here’s <code class="inline">static_paths</code> from my <code class="inline">clutterstack_web.ex</code> file:</p> <aside class="sidenote rowspan-7 "> <p> I refer to modules by their filenames sometimes. It was helpful for me to realise, though, that while Phoenix has conventions for module filenames and directories, it’s the module name and definition inside the file that’s important. You can organize modules in their <code class="inline">.ex</code> files how you like.</p> <p> When I was starting out, I didn’t get this, and worried way too much about where to put module files and what to call them.</p> <p> (This doesn’t go for <code class="inline">.exs</code> files, which are definitely referred to by their locations and filenames.)</p> </aside> <pre><code class="makeup elixir"><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="nf">static_paths</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="sx">~w(assets fonts images favicon.ico robots.txt)</span></code></pre> <p> (The <a href="https://hexdocs.pm/elixir/sigils.html#word-lists"><code class="inline">~w</code> sigil</a> converts space-separated words into a list of strings.)</p> <p> So <code class="inline">priv/static/robots.txt</code> gets served at <code class="inline">/robots.txt</code> and images at, e.g. <code class="inline">/images/whatever.jpg</code>.</p> <p> I have also have sitemap files inside <code class="inline">priv/static/sitemaps/</code>. If I include <code class="inline">sitemaps</code> in the above <code class="inline">:only</code> option, these files will be served at <code class="inline">/sitemaps/sitemapfile.xml</code>. I’d prefer to use the root path where indexers look by default: <code class="inline">https://clutterstack.com/sitemap.xml</code>.</p> <p> So I added another static plug to <code class="inline">endpoint.ex</code> just for sitemaps:</p> <pre><code class="makeup elixir"><span class="w"> </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Static</span><span class="p">,</span><span class="w"> </span><span class="ss">at</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">from</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7995011777-1">{</span><span class="ss">:clutterstack</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;priv/static/sitemaps/&quot;</span><span class="p" data-group-id="7995011777-1">}</span></code></pre> <p> Bob’s your uncle; all my sitemap files are served at the root path. </p> <p> This wasn’t the only solution to making my sitemap easy for robots to find; <a href="https://developers.google.com/search/docs/crawling-indexing/robots/create-robots-txt">you can also specify a non-default location of a sitemap file in <code class="inline">robots.txt</code></a> (developers.google.com). </p>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2024-10-24-llm-observations/</id>
    <title>Building beyond my skills with an LLM</title>
    <updated>2024-10-24T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2024-10-24-llm-observations/"/>
    <content type="html"><![CDATA[<p> I build things beyond my skills all the time. That’s how I get better at stuff. This time I added “working with LLMs” to the set of skills to improve. </p> <p> I had a nebulous idea—it’s difficult to express how slippery it seemed to me at the time—for something I wanted to do in my Elixir app. I thought I’d like to be able to validate (and maybe later build) request bodies for a specific API, which can contain cascades of nested configuration options. I had access to a JSON OpenAPI spec from <a href="https://docs.machines.dev">docs.machines.dev</a>, and <a href="https://github.com/ckreiling/fly_machines">ckreiling’s lovely, tidy Req-powered client for the Fly Machines API</a>.</p> <p> I didn’t know where to start. I was missing a variety of expertise. Whole abstract patterns. Best practices. Common tools.</p> <p> The one fixed parameter was that I was going to try to lean hard on an LLM for help. I started a subscription to Claude Pro, so I could ask lots of dumb questions. </p> <aside class="sidenote "> <p> I assume I’d be writing a very similar post if I’d subscribed to ChatGPT Plus instead.</p> </aside> <h2> Defining the task</h2> <p> I asked Claude some very general questions about things that I might want to do.</p> <p> Here’s my biggest bang-for-buck prompt:</p> <blockquote> <p> <code class="inline">I&#39;ve got a library that generates API requests. But it doesn&#39;t validate with any schema or type for the parameters. What kind of tool should I have for that</code> </p> </blockquote> <p> Claude gave me an example of an Ecto schema with a changeset and some code to check parameters against the changeset. This is a strong signal, if you trust the judgement of the clue-giver! </p> <p> It also suggested <a href="https://github.com/jonasschmidt/ex_json_schema">ExJsonSchema</a>, <a href="https://github.com/CargoSense/vex">Vex</a>, Dashbit’s <a href="https://github.com/dashbitco/nimble_options">Nimble Options</a>, or writing a custom validation module. </p> <p> In the same session, I asked about Elixir tools for working with an OpenAPI spec and got back <a href="https://github.com/open-api-spex/open_api_spex">OpenApiSpex</a>, <a href="https://github.com/OpenAPITools/openapi-generator">OpenAPI Generator</a> (or did it mean <a href="https://github.com/aj-foster/open-api-generator">this one?</a>), ExOpenApi (which I couldn’t find), and <a href="https://github.com/swagger-api/swagger-codegen">Swagger Codegen</a>.</p> <p> An embarrassment of riches! The hard fact is that I had to do some reading and testing to sort out what I wanted from here. I could have asked Claude for more guidance, and I’ll explore that in the future.</p> <p> Once the dust had settled, I’d decided to use Ecto schemas and changesets to hold the rules my request bodies have to obey.</p> <div class="callout"> <p> Notes on some of the options for my project:</p> <p> <a href="https://hexdocs.pm/ecto/embedded-schemas.html">Ecto embedded schemas</a> provide validation through changesets, using a library already present in a lot of projects. Nested schemas seem to work robustly. You do need something to generate the Ecto schemas and changeset definitions from the JSON spec. This option was the winner.</p> <p> <a href="https://hexdocs.pm/nimble_options/NimbleOptions.html">Nimble Options</a> needs schemas to come from somewhere, too, but it does validation and handles nested options without depending on Ecto. I didn’t follow this very far, but I’m very curious to play with it more, given its light weight and its documentation possibilities.</p> <p> <a href="https://github.com/open-api-spex/open_api_spex">OpenApiSpex</a> has validation functionality and can import an existing schema file, but it didn’t immediately fill in all of the nested schemas, and I moved on in my explorations. I would look at this lib again if I were writing my own API.</p> <p> The <a href="https://github.com/OpenAPITools/openapi-generator/blob/master/docs/generators/elixir.md">OpenAPI Generator for Elixir</a> doesn’t seem, for one thing, to support <code class="inline">allOf</code>, which I needed. I don’t need a client library so I’d probably have gone with a simpler solution in any case.</p> <p> For existing schemas in the form of structs or maps, <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#module-schemaless-changesets">Ecto schemaless changesets</a> look like a relatively painless way to add validation if you’re already familiar with changesets and have Ecto in the project.</p> </div> <h2> Seeing how much Claude will build for me</h2> <p> The problem was now much better defined: I wanted to write a tool to read the <code class="inline">spec.json</code> file for the API, and spit out all the <code class="inline">Ecto.Schema</code> modules I needed, complete with changesets.</p> <p> I still didn’t know how to do it. I didn’t properly understand Ecto changesets, so I didn’t understand how to use them without a database. I hadn’t read through the JSON spec for the API I want to interact with (though I’m very familiar with parts of the API as a user) and hadn’t thought about the OpenAPI or Swagger API specification as a format.</p> <p> Instead of going and figuring all those things out, I uploaded the <code class="inline">spec.json</code> file into the project and asked Claude to just write me the whole Elixir module. I’d test it and report back with the latest compilation error or problem with its output. That’s basically all I did until I noticed that fixing one thing would lose the previous fix. It was time to start helping Claude steer.</p> <h2> Taking my bearings</h2> <p> So I wasn’t going to reach a working product just by prompting an LLM, and then read it to learn how it worked. :P</p> <p> But now there was a buggy version of the whole tool, all roughed in. </p> <p> Normally, I’d start with some minimal testable function and build out toward the bigger picture. But by returning to natural language, I’d been able to scope the project even while large areas of my mental map of the implementation were blank. An initial scope was not only suggested, but planted and taking root in my editor.</p> <p> I suspect this will prove a powerful tool to prevent rabbit-holing, to which I’m susceptible when I’m uncertain which parts of the map I should fill in. Sure, this mode of work will have its own kinds of tangents to fly off on. But the scoping effect is exciting.</p> <h2> Drilling down</h2> <p> At this point it was time to consolidate my understanding and start driving what the individual functions do. </p> <p> I’d been learning as I worked with Claude’s suggestions and so was better equipped to think critically about the different things the module should do and how to do them.</p> <p> This was much more straightforward work. The LLM was still a great help to figure out things that I couldn’t immediately glean from documentation or a Google search for blog posts or forum discussions.</p> <p> In this phase it can be handy to keep a tab open with ChatGPT or Gemini for quick second opinions.</p> <h2> So…success?</h2> <p> Now I have a Mix task that reads the <code class="inline">spec.json</code> for the Fly Machines API and spits out Ecto schema modules. It’s not pretty, and I bet there are a bunch of edge cases I haven’t accounted for, but through the process I’ve learned enough to make it good, if I want to. I’m now doing a little bit of validation in another project using these schemas. </p> <p> You can read more about the end product, how it works, and its foibles at GitHub: <a href="https://github.com/clutterstack/openapi-json-to-ecto">clutterstack/openapi-json-to-ecto</a>.</p> <p> I could certainly have muddled my way to this point without an LLM, and I certainly muddled my way to this point with one too. I did all the things in a different order from usual. It’s pretty hard to compare. </p> <p> I did enjoy having a wad of flawed code that gave me a shape and scope to work with.</p> <p> The goalposts will keep moving, both on the side of the models and tools available and in my own brain, but I think if there’s one rule of thumb to keep in mind for “next time” it’s “as soon as you make any progress, consciously consolidate your understanding of what you’re doing.” </p> <p> Which makes sense in most contexts.</p> <h2> Appendix 1: An algorithm I may follow “next time”:</h2> <ul> <li> Start by spending a bit of time prompting at the most general level, if there’s any uncertainty about the goal or the broadest direction. </li> <li> Ask for a whole program to do something. Test it out, ask followup questions to fix unexpected results and errors, for a bit. </li> <li> When the new program runs without errors, and its behaviour is anything like the right thing, STOP and figure out everything it’s doing. </li> <li> If there’s no obvious architectural change to make, start prompting for possible approaches to <em>parts</em> of the program. Instead of the whole program, start new chats with just a function or two, some input (or a description thereof), what you wanted it to do, and the error or unexpected result. </li> </ul> <h2> Appendix 2: Further notes about using Claude in October 2024:</h2> <ul> <li> Even when working with projects, start new chats when a significant part of the history in the current one isn’t needed in the context anymore. Claude warned me (Oct 2024) that I was sending the whole chat back and forth every time, burning my allowance. This very handy info was pushed to me through the UI, and is also easy to find <a href="https://support.anthropic.com/en/articles/8324991-about-claude-pro-usage">on Anthropic’s website</a>. Colour me impressed with Anthropic’s cohesive content and documentation strategy. </li> <li> You can get a helpful, correct suggestion with one prompt, and then a weird, wrong suggestion with a very similar one. When this happened to me, I hadn’t known the good approach existed beforehand. So if I’d seen the bad approach first, I might have tried to go with that. </li> <li> As others have observed, once a program does enough stuff, you can ask Claude to fix one behaviour and it’ll cause a regression in another one you just fixed. Then it’s probably time to work with a smaller chunk of code, not least to ensure that unrelated working code doesn’t get changed capriciously. </li> </ul>]]></content>
  </entry>
</feed>