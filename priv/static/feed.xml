<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://clutterstack.com/</id>
  <updated>2025-08-01T03:12:13.765302Z</updated>
  <title>Clutterstack</title>
  <link rel="self" href="https://clutterstack.com/feed.xml"/>
  <author>
    <name>Chris Nicoll</name>
  </author>
  <entry>
    <id>https://clutterstack.com/posts/2025-07-31-claude-wrote-me-a-tui-all-i-got-was-this-stupid-tui/</id>
    <title>Claude wrote me a TUI and all I got was this stupid TUI</title>
    <updated>2025-07-31T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-07-31-claude-wrote-me-a-tui-all-i-got-was-this-stupid-tui/"/>
    <content type="html"><![CDATA[<p> <img src="/images/2025-07-31-screenie.webp" alt="Stream2blog TUI in thread view mode, showing numbered snippets and total word count on the left, a text preview and image thumbnail on the right, and shortcut key help at the bottom."> </p> <p> Writing is hard. I usually overthink it.</p> <p> Punch-drunk inspiration hit me late one night, after I’d mindlessly deposited the highlights of a day hike into a Slack thread: working under similar constraints and conveniences, could I barf out a blog post almost as easily? </p> <p> Rather than compose my next article in Slack DMs with myself, I went for the second-most-practical proof of principle: creating a new tiny writing app that emulates the microblogging experience.</p> <p> I already had a gaggle of unfinished projects. But I was feeling good about Claude Code, and easily sniped by what looked like a quick vibe-coding side quest. So off I went!</p> <aside class="sidenote "> <p> They’re honking expectantly and pecking at my shoelaces. </p> </aside> <h2> Initial spec</h2> <p> I had a pretty clear set of basic requirements, as a user:</p> <ul> <li> A basic editor for composing short entries. Entries should drop into a “thread” that can be spit out into a single Markdown file when I’m ready to call it a draft. </li> <li> A hard character limit per entry, complete with colour-changing character counter to ratchet up anxiety in inverse proportion to conciseness. </li> <li> Some stupid-simple way to add a single image to an entry. Ideally: paste from the OS clipboard. With LLM help, it’ll be easy to add resizing and conversion to WebP, or whatever makes it easier to get from train-of-thought to published on my blog. </li> </ul> <h2> Scheming</h2> <p> For a break from the browser, and to satisfy my craving for novelty, I decided to do a text-based user interface (TUI).</p> <p> A quick web search turned up strong TUI libraries for Go, Python, and Rust (<a href="https://github.com/charmbracelet/bubbletea">Bubble Tea</a>, <a href="https://textual.textualize.io/">Textual</a>, and <a href="https://docs.rs/ratatui/latest/ratatui/index.html">Ratatui</a>, for respective example). </p> <p> The novelty factor tipped the balance to Rust. Bonus: that means this can be a Rust client and Elixir/Phoenix storage API backed by SQLite, a <a href="https://www.dc.com/characters/bizarro">Bizarro</a> twin for the Phoenix-app-with-state-in-a-Rust-program that I bumped to the back burner to work on this.</p> <aside class="sidenote rowspan-4 "> <p> There are reasons this isn’t quite pants-on-head preposterous. </p> <p> My Elixir/Phoenix blog stores content in SQLite; putting storage on the Elixir side of an API boundary lets me eject from Rust if I want.</p> <p> I can run multiple instances of the Rust program, because the Elixir app owns the db. (Well, I bet it’s like 90% safe.)</p> </aside> <p> For the record: Claude assured me that this was a brilliant design. </p> <h2> Fast-forward through the actual vibing</h2> <p> I started by working out, with Claude, design docs for the TUI and the Elixir storage app. </p> <p> From there I tried to let Claude generate the code, with appropriate interactive planning and feedback; I wanted to touch Rust, but not too much. Vibing was particularly easy at first when there was nothing but a green field, Claude Code, and a language I couldn’t so much as read a function signature in.</p> <p> I don’t have anything new to say about the process. Any specific observations will be stale by…well, by now, probably. So let’s skip forward.</p> <aside class="sidenote "> <p> I cheated and put an appendix at the bottom.</p> </aside> <h2> So, it worked</h2> <p> Leaning heavily on Claude Code over the course of several days, I generated <a href="https://github.com/clutterstack/stream2blog">a working (if buggy) blogging application</a> that’s arbitrarily close to what I was looking for, without understanding everything that was going into it.</p> <p> <img src="/images/2025-07-31-yellow.webp" alt="Stream2blog TUI with 350 characters of text in the editor and a yellow character counter showing 350/400"> </p> <p> In an alternate universe where I’d learned some Rust and read the <a href="https://ratatui.rs/">Ratatui</a> docs <em>first</em>, this would have been a (for the most part) simple project to build out of a TUI library and third-party widgets. Crates like Ratatui, <a href="https://crates.io/crates/tui-textarea">tui-textarea</a>, <a href="https://crates.io/crates/ratatui-image">Ratatui-image</a>, <a href="https://crates.io/crates/arboard">Arboard</a>, and <a href="https://crates.io/crates/textwrap">Textwrap</a> do the heavy lifting. </p> <p> The main twist was that tui-textarea doesn’t do word wrap, and it was easier to fork it to use the Textwrap library than to do text wrapping on top of it.</p> <h2> After the vibe</h2> <p> In July 2025, was “vibe coding” the way to do this?</p> <p> No way, not this project, regardless of your definition of “vibe”. </p> <p> There’s not much novelty in using a new language only to minimise how much of it you learn.</p> <aside class="sidenote rowspan-5 "> <p> A Karpathy tweet (not that one): </p> <blockquote> <p> I inherited “AI assisted coding” from this @simonw post: <a href="https://simonwillison.net/2025/Mar/19/vibe-coding/">https://simonwillison.net/2025/Mar/19/vibe-coding/</a> </p> <p> But I think it needs work. It doesn’t roll off the tongue. </p> <p> Few days ago a friend asked me if I was vibe coding and I said no I’m “real coding”. Possible candidate :D </p> </blockquote> <p> – <a href="https://x.com/karpathy/status/1915586183834587218">https://x.com/karpathy/status/1915586183834587218</a></p> </aside> <p> Ratatui and friends have really helpful documentation, and abundant examples to crib from. I absolutely am impressed by how far Claude Code got with these libraries. But the docs are better than that.</p> <p> In the land of Rust and Ratatui, I’m a tourist and Claude’s a guide that can’t think about the whole map at once. If I wanted to do this faster, and I really wanted to use Rust, I should have tried the examples and used LLMs to build my understanding.</p> <p> I did learn a teensy bit of Rust. It would have been tricky to get this far otherwise. Sometimes you can see what’s wrong but it’s exasperatingly hard to nudge an LLM into fixing it right.</p> <p> A weird effect of being insulated from learning while building a bespoke application: now I have a program that’s comfortable for me to use, full of bugs and antipatterns that I have only the merest inkling about, and I couldn’t in good conscience suggest anyone use it or fork it.</p> <p> Worse, I forked one of my dependencies to overcome the <a href="https://github.com/rhysd/tui-textarea/issues/5">longest-standing GitHub issue</a> on that project, and haven’t got anything good to offer back upstream. Who knows what nonsense is in there, and which other features I broke? Not me.</p> <h2> What about the Elixir backing app?</h2> <p> Looks like I vibed that one for real. Claude is so comfy with Phoenix and Ecto that I’ve hardly had to look at the storage app. No human brain cell has been bothered about a SQLite schema here. </p> <p> I’d now trust Claude.ai or Claude Code to <a href="https://clutterstack.com/posts/2025-03-12-claude-scarily-good-faking-deterministic-output">generate a one-off API client</a> in a language I can read (thus test and debug), without the buffer of getting it to write a program to do the conversion. </p> <p> What I wasn’t appreciating in March of this year is that these interfaces are not simple wrappers for an LLM—while I’m not sure if Claude.ai was unequivocally agentic at that point, it is now.</p> <aside class="sidenote "> <p> That being said: we can’t trust Claude Code and Claude Sonnet 4.0, in July 2025, to infer that if all existing database operations happen using API calls, the app should probably not start writing directly to the db file.</p> </aside> <h2> But can you barf out a blog post now?</h2> <p> Of course not. Writing is hard. This article alone took days of vibe coding.</p> <p> Are my constraints and conveniences good for anything? So far, I’m encouraged. I used the new app to bootstrap this post. It helps me keep track of the shape of a thread without showing it all to me at once. I <em>can</em> start new entries to add words, but the per-entry character limit actively reminds me to encapsulate my point.</p> <p> It can still be tempting to organise a single thread into sections and move entries between them, which is a danger sign.</p> <p> The convenience of pasting images is gratifying, but I haven’t really had occasion to put it through its paces, and there’s still a bug or two around removing them. I still think it’ll be cool.</p> <p> If I use this to write another post after this one, I’ll say I was on to something.</p> <h2> Appendix: A smattering of Summer 2025 souvenirs (coding-with-LLMs-wise)</h2> <ul> <li> <p> Lazy cheat code: ask “why.” When debugging, Claude sometimes gets fixated on the first possibility it sees from wherever its attention is, and goes ahead with useless changes. When Claude seems to be having a bad day, asking it to explain why the program is behaving like that, before asking it to solve anything, can help keep it out of that rut. I haven’t added this to my CLAUDE.md yet, but I probably should. </p> </li> <li> <p> Alternate lazy cheat for bad days: ask “how does the module handle <code class="inline">$WHATEVER</code>“ when you know it’s doing <code class="inline">$WHATEVER</code> wrong, and sometimes it’ll figure it out without you having to complain about symptoms. </p> </li> <li> <p> Claude likes to add diagnostic logs. I’m glad it doesn’t spontaneously remove logging, I guess, but I wonder if noisy logging makes a material difference to token usage or can pollute the context meaningfully. So I try to keep those from getting too wild. Similar for compilation warnings, which I otherwise have a tendency to let build up. </p> </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2025-06-01-liveview-machine-affinity/</id>
    <title>Machine Affinity with LiveView and fly-replay</title>
    <updated>2025-06-01T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-06-01-liveview-machine-affinity/"/>
    <content type="html"><![CDATA[<p> I’ve been building an application to exercise some features of Phoenix/LiveView and Fly Machines. It’s <a href="https://where.fly.dev">a button</a>.</p> <p> You push the button. It makes an API call. A new virtual machine pops up on some Fly.io metal in the data centre nearest to you.</p> <aside class="sidenote rowspan-2 "> <p> Nearest, that is, to the Fly.io edge server you hit using the app’s Anycast IP address. If your ISP and its BGP friends are having a bad day, your request could take the scenic route.</p> </aside> <p> Once the new VM is up, the LiveView redirects your browser to it. Your very own Fly Machine serves you some content, then shuts itself down and gets destroyed forever.</p> <p> The whole schtick collapses if I don’t ensure any button-pusher can interact only with the Machine they launched. </p> <p> This looks like a type of session affinity, or sticky sessions, problem.</p> <h2> The key to sticky sessions within a Fly <code class="inline">app</code> is <code class="inline">fly-replay</code></h2> <p> Backing up: the Fly.io load balancer is a Rust program called fly-proxy. When you visit an app’s public URL, fly-proxy relays your request from the edge to a Machine with a service <a href="https://fly.io/docs/machines/api/machines-resource/#machine-config-object-properties">configured</a> on the right port and the concurrency headroom to fulfil it. In the simplest case, that’s the closest such Machine in the app. Machine state and autostart config also factor in, when they’re relevant. </p> <aside class="sidenote rowspan-1 "> <p> If you’re curious about the kind of distributed-state wrangling fly-proxy has to do to accomplish all that, there’s a peek in the intro paragraphs of <a href="https://fly.io/blog/parking-lot-ffffffffffffffff/">this 2025 Rust debugging episode on the Fly.io blog</a>.</p> </aside> <p> There’s no way to tell fly-proxy beforehand that it should deliver an HTTP request to Machine B with a service exposed on port 80, and not the nearer Machine A in the same app with a service on port 80. But it does provide for application code to examine the request and respond with a <a href="https://fly.io/docs/networking/dynamic-request-routing/"><code class="inline">fly-replay</code></a> header, telling it to deliver the request again; to a different app, to a specific region, or to not-this-Machine, and fly-proxy applies its load-balancing logic within those constraints. Or we can pin the replay down to a specific Machine.</p> <aside class="sidenote rowspan-2 "> <p> If we have control of the client, we can skip the bounce with a <code class="inline">fly-force-instance-id</code> or <code class="inline">fly-prefer-region</code> header, but visitors’ browsers rightly don’t let our websites add arbitrary headers to their outgoing requests.</p> <p> There’s classic reading on fly-proxy and <code class="inline">fly-replay</code> inside <a href="https://fly.io/blog/globally-distributed-postgres/#the-fly-replay-header"><em>Globally Distributed Postgres</em> (2021)</a>.</p> </aside> <p> This makes the proxy sort-of programmable without actually making it programmable.</p> <h2> An app per customer may be better than <code class="inline">fly-replay</code></h2> <p> If the Closest Machine is frequently the Wrong Machine, and you’re constantly replaying requests, it may be worth putting each distinct Machine into its own Fly <code class="inline">app</code> with its own <code class="inline">.fly.dev</code> URL. </p> <p> If you’re isolating workloads/users on their own VMs for security reasons, putting them into their own apps too is even better, because you can wall apps off into separate <a href="https://fly.io/docs/networking/custom-private-networks/">custom IPv6 private networks</a>.</p> <p> In my case, though, <code class="inline">fly-replay</code> is just the ticket. fly-proxy has a high chance of hitting the correct Machine on the first try. The whole visitor experience is short and I don’t want to bog it down with more API operations and waiting for DNS. (And while I could generate disposable app names with a vanishing likelihood of collision, burning globally unique app names just feels stinky.)</p> <p> So from here I just have to implement the logic in my LiveView app to issue a <code class="inline">fly-replay</code> for every request that needs one. It’s not quite straightforward.</p> <h2> Peter Ullrich solved this exact thing already</h2> <p> As it happens, Peter Ullrich <a href="https://peterullrich.com/request-routing-and-sticky-sessions-in-phoenix-on-fly">wrote an article</a> on using <code class="inline">fly-replay</code> for sticky sessions on Fly.io with a Phoenix/LiveView application. It’s pretty neat, and he explains both the why and the how; I’ll recap what stood out to me, but you should read his version for the good stuff.</p> <p> Ullrich wrote a <a href="https://hexdocs.pm/plug/Plug.html#module-module-plugs">module plug</a> that checks each incoming request for a query parameter, or failing that, a cookie, matching the ID of the current Machine. If the query parameter matches, it puts that into a session cookie so that it’s passed in with all subsequent requests from that client (until that cookie gets changed). If there’s a parameter or a cookie, but it doesn’t match, the plug responds with a <code class="inline">fly-replay</code> header and a redirect status (307). </p> <aside class="sidenote "> <p> This 307 code is basically a placeholder. fly-proxy doesn’t care what status code or body you put on the response, and it doesn’t pass responses containing <code class="inline">fly-replay</code> back out to the client.</p> </aside> <p> The tricky part in a LiveView application is getting every request to go through that plug. WebSocket connection requests don’t go through the router, nor through the regular plugs in the endpoint, so just adding a plug in either of those modules doesn’t cut it.</p> <p> To ensure everything, <em>everything</em>, goes through a particular plug, you can override the definition of the endpoint’s <code class="inline">Plug.call/2</code> callback to run through that plug first. </p> <p> The plug either issues a <code class="inline">fly-replay</code> or dumps the <code class="inline">conn</code> into the front end of the stock endpoint to be handled in the usual way.</p> <p> Again, I didn’t figure this out myself; go read the <a href="https://peterullrich.com/request-routing-and-sticky-sessions-in-phoenix-on-fly">original post</a>.</p> <h2> I tried to squirm out of it</h2> <p> When I first read Ullrich’s article, I refused to believe that my use case wasn’t simpler.</p> <p> I thought I should be able to start with something like a vanilla LiveView authentication/authorization setup and simplify that down to some path-based logic with a <a href="https://hexdocs.pm/phoenix_live_view/security-model.html#live_session"><code class="inline">live_session</code></a> and an <code class="inline">on_mount</code> hook to gate access to the LiveView and <code class="inline">fly-replay</code> any requests for a path indicating a different Machine.</p> <p> This almost worked!</p> <p> Just kidding; of course it didn’t.</p> <p> An <code class="inline">on_mount</code> hook can’t manipulate connections the way a plug can, and it can’t send a <code class="inline">fly-replay</code> header. It can do a redirect to a route in the router module, though. </p> <p> For a moment I thought it would be clever to get the <code class="inline">on_mount</code> callback to check the path against the <code class="inline">FLY_MACHINE_ID</code> environment variable (this part is fine) and if needed, cycle the connection back to the router and through a plug, which <em>can</em> set headers and respond. </p> <p> If it’s not obvious, what this accomplishes, when you hit the wrong Machine, is an infinite loop of <code class="inline">fly-replay</code> “redirects”. </p> <p> Getting a LiveView rendered and connected involves two requests, running its <code class="inline">mount</code> function twice. The first <code class="inline">on_mount</code> catches a request meant for another Machine, and replays to that Machine. But the WebSocket upgrade needs one more HTTP request.</p> <aside class="sidenote "> <p> I like <a href="https://kobrakai.de/kolumne/liveview-double-mount">Benjamin Milde’s article about the LiveView double mount</a>.</p> </aside> <p> If fly-proxy thought the wrong Machine was a good choice the first time, it probably thinks the same thing this time too, and sends the upgrade request there, where the <code class="inline">on_mount</code> callback sends it back to the router on the right Machine, where we start all over again.</p> <h2> Tweaks</h2> <p> I used Ullrich’s solution wholesale, with two adjustments to the plug:</p> <ul> <li> I added a condition to let requests to <code class="inline">/health</code> pass; localhost needs to reach it. A plug in the router pipeline blocks non-localhost connections. </li> <li> Instead of passing all connections that don’t match one of the conditions, I block them. There’s no resource that you should be looking for on this Machine if it’s not the Machine you created. </li> </ul> <p> My adaptation is in <a href="https://gist.github.com/clutterstack/97a66b4b7d7d82babf586962e80ade95">this gist</a>.</p> <p> Push the button at <a href="https://where.fly.dev">https://where.fly.dev</a>. See if it works for you.</p>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2025-03-12-claude-scarily-good-faking-deterministic-output/</id>
    <title>Claude got scarily good at faking deterministic output</title>
    <updated>2025-03-12T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-03-12-claude-scarily-good-faking-deterministic-output/"/>
    <content type="html"><![CDATA[<p> The other day, I accidentally got Claude 3.7 Sonnet to generate a thousand-line, <a href="https://hexdocs.pm/req/">Req</a>-based Elixir API client from the <a href="https://docs.machines.dev/">OpenAPI spec for Fly Machines</a>.</p> <p> I was exploring the options for structuring such a module, more out of curiosity than any urgent need, and asked Claude on a whim if it could produce functions for all the endpoints. It did. Forty-odd functions, complete with typespecs and detailed docstrings. It hit its message-length limit and I had to ask it to carry on in a new message. It picked up and finished without incident. </p> <aside class="sidenote rowspan-2 "> <p> I have had zero previous success getting a complete response with the “continue” option in Claude chat. Admittedly it’s got to be trickier when the too-long message has interdependent functions that it has to reconcile.</p> </aside> <p> The output looks solid. It looks consistent. Claude doesn’t seem to have so much as supplemented the request parameters with a popular one from some other API.</p> <p> I was really impressed that Claude sustained such an uncanny impersonation of a dumb but reliable Python script for that long—despite the Vaudeville hook dragging it offstage partway through the act.</p> <aside class="sidenote rowspan-1 "> <p> Or <a href="https://github.com/OpenAPITools/openapi-generator/">Java program</a>.</p> </aside> <p> Also: this is terrible. Now I can sneeze and a nondeterministic black box barfs out a thousand lines of independent functions and docs oozing respectability and discipline? I’m going to be so tempted to trust this!</p> <p> If I’d planned an exhaustive client for this API, I’d have asked my machine buddy for help writing a boring Python script (or Mix task) to convert the OpenAPI spec directly, reproducibly, and with a lot less electricity.</p> <aside class="sidenote rowspan-1 "> <p> <a href="/posts/2024-10-24-llm-observations">Which is what I did</a> when I wanted <a href="https://hexdocs.pm/ecto/embedded-schemas.html">Ecto embedded schemas</a> to validate parameters going out in request bodies.</p> </aside> <p> I should note that the docstrings I ended up with are richer than what’s in the spec. Some of the example material identifiably originated in <a href="https://fly.io/docs/machines/api/">Fly.io developer docs</a>. So, there’s that.</p> <h2> Now that I have all that code</h2> <p> This may be the first time an LLM tool has bitten off more than <em>I</em> can chew without losing its own bearings. The vibes were practically telepathic.</p> <p> I don’t <em>approve</em> of using an LLM for tasks that need repeatability and can be done in seconds on a CPU. I can’t be sure there are no surprises until I’ve checked every function, and if I ask again, there’s no guarantee any deficiencies will be the same ones.</p> <p> But here’s the module, fully formed. What to do?</p> <p> I <em>do</em> want to talk to a subset of this API from my Elixir apps, and this gives me a starting point for incorporating the schema validation I’ve been playing with. </p> <p> I could “ship” it and fix it if I ever find out it’s broken—the stakes couldn’t be lower. But all those untried functions, all that unexamined documentation in my module—it was stressing me out.</p> <p> I took the easy way out: the reusable moving parts and a couple endpoint functions go into a module and the rest get banished into a slush file outside my project. I don’t have to look at them, but I can grab them as needed, if they ever are. Instant relief.</p> <aside class="sidenote rowspan-1 "> <p> The file’s called <code class="inline">jello.ex</code>. It’s tastier than slop and holds its shape better.</p> </aside> <h2> More things I think about LLMs, March 2025 edition</h2> <p> As always, the quality of the output of an LLM chat tool is entangled with the quality of my side of the conversation. It’s all moving targets and YMMV.</p> <ul> <li> The Elixir ecosystem abounds with high-signal, well-structured documentation. Claude’s grounding in Elixir has improved immensely in the past year. In my opinion, between the two we’ve hit a tipping point for a coding-while-learning momentum boost. </li> <li> Once the shiny, clean module appeared, I immediately got Claude to start messing it up by asking it a question about Req options. I think questions like “do I have to do X in order for Y to happen?” can be leading if there’s a weakness around Y in the model or the context. Claude is a bit too much of a people pleaser, and my lightweight attempts to counter that with project instructions and preferences haven’t cured that. </li> <li> It has happened, though, with both Claude and ChatGPT, that I’ve proposed one thing and the tool has correctly advised me to use a different approach. </li> <li> I do still wade into boggy ground with Claude 3.7, ask it to bite off more than it can chew and end up in a cycle of ineffectual “corrections”, or ask it something it doesn’t have a good grounding in and end up trying to find docs for nonexistent functions to help me implement some antipattern. </li> <li> At the end of February, I was surprised when Claude <em>3.5</em> Sonnet and I managed a very similar failure of attention navigating a bureaucracy of pattern-matching function heads. We both missed that the salient clause returned a value instead of handing it off to the next one in line. For all I know, this wouldn’t happen with 3.7. Claude can be so ultra-agreeable that I almost think I planted that blind spot by telling it what I couldn’t find. </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2025-02-27-iex-S-mix-phx-server/</id>
    <title>iex -S mix phx.server: What? How?</title>
    <updated>2025-02-27T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-02-27-iex-S-mix-phx-server/"/>
    <content type="html"><![CDATA[<p> <code class="inline">iex -S mix phx.server</code>: it starts up my Phoenix dev server under Elixir’s interactive shell program, <a href="https://hexdocs.pm/iex/IEx.html">IEx</a>, so I can call functions from my app and <a href="/posts/2025-01-30-observer-elixir">whatnot</a>.</p> <p> One day, it started to bug me <em>unreasonably</em> much that I didn’t really understand how this command causes that to happen. Perhaps culpable: a touch of delirium, downstream of the flu.</p> <p> There were a lot of reasons for my mystification (i.e. a lot of basic things I hadn’t thought much about before), so below you’ll find, if you want to, ~2700 words about some things that happen and how. I don’t expect even one whole person to read the entirety. It’s not that kind of blog post.</p> <p> There may be inaccuracies.</p> <h2> Interacting scripts</h2> <p> Before getting fancy, I want to know what my basic everyday Elixir commands do.</p> <p> The <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/elixir"><code class="inline">elixir</code></a>, <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/iex"><code class="inline">iex</code></a>, and <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/mix"><code class="inline">mix</code></a> commands are all scripts.</p> <aside class="sidenote rowspan-2 "> <p> I’m looking at the Unixy versions, but there are Windows <code class="inline">.bat</code> files too.</p> </aside> <h3> <code class="inline">elixir</code>, the script</h3> <p> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/elixir">The <code class="inline">elixir</code> shell script</a> constructs a string of arguments based on the arguments you supply, plus some information about your Elixir installation, and tacks that onto an <code class="inline">erl</code> command.</p> <aside class="sidenote rowspan-1 "> <p> The text for <code class="inline">elixir --help</code> comes from this file, too.</p> </aside> <div class="callout"> <p> <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html"><code class="inline">erl</code></a> comes with the Erlang distribution. It bootstraps an Erlang runtime environment, including starting a BEAM instance for everything to run on, and gets it to do the things indicated by the arguments. Unless you tell it not to, <code class="inline">erl</code> also supplies, and drops you into, the Erlang interactive shell.</p> </div> <aside class="sidenote "> <p> BEAM <a href="https://www.erlang.org/blog/beam-compiler-history/#beam-bogdans-erlang-abstract-machine">(Bogdan’s Erlang Abstract Machine)</a>: “the virtual machine that executes user code in the Erlang Runtime System (ERTS)” (John Högberg, <a href="https://www.erlang.org/blog/a-brief-beam-primer/"><em>A brief introduction to BEAM</em></a>)</p> </aside> <p> The <code class="inline">elixir</code> script ends with</p> <pre><code>if [ -n &quot;$ELIXIR_CLI_DRY_RUN&quot; ]; then echo &quot;$@&quot; else exec &quot;$@&quot; fi</code></pre> <p> It’s assembled the <code class="inline">erl</code> invocation, with all its arguments, into <code class="inline">&quot;$@&quot;</code>, and all that’s left is to execute that command. </p> <p> But look! By setting the <code class="inline">ELIXIR_CLI_DRY_RUN</code> env var, you can view the whole assembly instead of running it! I didn’t know that; I’m going to use it in a minute.</p> <h3> <code class="inline">mix</code>, the script</h3> <p> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/mix">The <code class="inline">mix</code> script</a> is exactly this:</p> <pre><code>#!/usr/bin/env elixir Mix.CLI.main()</code></pre> <aside class="sidenote rowspan-2 "> <p> <code class="inline">mix</code> help text comes from the <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/mix/lib/mix/cli.ex#L229"><code class="inline">display_usage/0</code></a> private function in <code class="inline">Mix.CLI</code>.</p> </aside> <p> This is an Elixir script! The shebang makes <code class="inline">mix</code> a (much) shorter way to write (in my case, with runtime installations managed by <a href="https://asdf-vm.com/">asdf</a>):</p> <pre><code class="sh">elixir /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/mix</code></pre> <p> So <code class="inline">mix</code> invokes <code class="inline">elixir</code> and we end up, again, with an <code class="inline">erl</code> command.</p> <p> This felt circular to me, because the <code class="inline">elixir</code> script doesn’t do anything with the contents of the <code class="inline">mix</code> script. But that’s just the way it works; rest assured that <em>something</em> eventually reads the file. We’ll see what, later.</p> <h3> <code class="inline">iex</code>, the script</h3> <p> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/iex">The <code class="inline">iex</code> shell script</a> ends with</p> <pre><code>exec &quot;$SCRIPT_PATH&quot;/elixir --no-halt --erl &quot;-user elixir&quot; +iex &quot;$@&quot;</code></pre> <p> Which is to say: it calls the <code class="inline">elixir</code> command with a specific set of arguments, followed by any arguments it was called with (<code class="inline">&quot;$@&quot;</code>). </p> <p> Another <code class="inline">erl</code> command.</p> <aside class="sidenote rowspan-2 "> <p> This explains why the help text for <code class="inline">iex</code>, for which this script happens to be the source, ends with this line: <code class="inline">It accepts all other options listed by &quot;elixir --help&quot;.</code> </p> <p> And it’s how we can use the <code class="inline">-S</code> flag with <code class="inline">iex</code>.</p> </aside> <p> <code class="inline">elixir --help</code> has entries for <code class="inline">--no-halt</code> (“[do] not halt the Erlang VM after execution”) and <code class="inline">--erl</code> (“[s]witches to be passed down to Erlang”). That <code class="inline">+iex</code> option isn’t in the help, but the <code class="inline">elixir</code> script does <a href="https://github.com/elixir-lang/elixir/blob/6ecb43061476c0870e24899a23ce8921835920d5/bin/elixir#L111">notice it</a>, and <a href="https://github.com/elixir-lang/elixir/blob/6ecb43061476c0870e24899a23ce8921835920d5/bin/elixir#L217">omit <code class="inline">-s elixir start_cli</code> from its <code class="inline">erl</code> arguments</a>. </p> <p> But we don’t have to work out the final set of arguments by reading the scripts. We can just print them out by setting the <code class="inline">ELIXIR_CLI_DRY_RUN</code> environment variable.</p> <h2> Pause to appreciate coolness</h2> <p> My Erlang/OTP installation doesn’t know anything about my Elixir installation.</p> <p> The arguments in these human-readable <code class="inline">erl</code> commands will have to tell it, or point it at, everything it needs to know in order to do whatever Elixir-land thing I wanted. This is not trivial or banal. It is very cool.</p> <h2> How to read <code class="inline">erl</code> arguments</h2> <p> So: <code class="inline">elixir</code> runs <code class="inline">erl</code> with a collection of arguments. And <code class="inline">iex</code> and <code class="inline">mix</code> both go through <code class="inline">elixir</code>. That is, each of these commands generates an <code class="inline">erl</code> command.</p> <aside class="sidenote "> <p> I neglected <a href="https://hexdocs.pm/elixir/modules-and-functions.html#compilation"><code class="inline">elixirc</code></a> but a quick check shows that <a href="https://github.com/elixir-lang/elixir/blob/v1.18/bin/elixirc">it, too, calls <code class="inline">elixir</code></a>.</p> </aside> <p> The <code class="inline">erl</code> docs do a pretty good job of <a href="https://www.erlang.org/doc/apps/erts/erl_cmd#erl-arguments">explaining the different kinds</a> of argument that <code class="inline">erl</code> accepts, and what it does with each kind.</p> <p> It can be a bit hairy to categorise them in practice. The following paraphrases info that’s in the docs, with some emphasis on “subtleties” that I missed in my first reading, and that would have saved me some casting about in source code.</p> <ul> <li> <p> <a href="https://www.erlang.org/doc/apps/erts/erl_cmd#emu_flags"><strong>Emulator flags</strong></a> are for VM settings. Emulator flags start with a plus sign, <a href="https://www.erlang.org/doc/apps/erts/erl_cmd#erl-arguments">except when they start with a hyphen like all the other flags</a>. We won’t run into any emulator flags in this exercise. </p> </li> <li> <p> Many, but not all, <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">other defined flags</a> are marked as <strong>init flags</strong>: flags that are interpreted and used by Erlang’s <code class="inline">init</code> and not stored for later use. </p> </li> <li> <p> <code class="inline">--</code> and <code class="inline">-extra</code> are init flags that indicate that what follows is one or more <strong>plain_arguments</strong>: values that the <code class="inline">init</code> stores in a list that you can get later with <a href="https://www.erlang.org/doc/apps/erts/init.html#get_plain_arguments/0"><code class="inline">init:get_plain_arguments/0</code></a>. </p> </li> <li> <p> You, the user, can create <strong>user flags</strong> to suit your needs. The <code class="inline">init</code> stores user flags as key-value pairs, where the flag becomes an atom key for a value that’s a list of the items that follow (up until the next flag). To get this list, use <a href="https://www.erlang.org/doc/apps/erts/init.html#get_arguments/0"><code class="inline">init:get_arguments/0</code></a>. If an argument starts with a hyphen, and it’s not an init flag, an emulator flag or a plain argument, it’s a user flag. </p> </li> <li> <p> Some code that comes with the Erlang distribution looks for arguments stored with specific user flags. Some of these user flags are <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">documented alongside the init flags</a>. </p> </li> <li> <p> Case in point: there’s an important special-case user flag <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">documented</a> as <code class="inline">-Application Par Val</code>; when/if the OTP application named <code class="inline">Application</code> is started, <code class="inline">Application</code>‘s <code class="inline">Par</code> configuration option is set to <code class="inline">Val</code>. We see this shape of user flag in the <code class="inline">elixir</code> command. This one tripped me up; I could see the apparent intent but missed it in the docs. </p> </li> </ul> <h2> <code class="inline">elixir</code>, <code class="inline">mix</code>, <code class="inline">iex</code>: the <code class="inline">erl</code> angle</h2> <p> Armed with the above clues to how <code class="inline">erl</code> statements work, let’s look at minimal examples of each of our Elixir commands.</p> <h3> <code class="inline">elixir</code></h3> <p> If I don’t put something after <code class="inline">elixir</code>, it just prints its help at me, so I’ll tell it to print <code class="inline">hi</code> instead.</p> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 elixir -e &#39;IO.puts(&quot;hi&quot;)&#39;</code></pre> <p> Here’s what that spits out:</p> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -s elixir start_cli \ -extra -e IO.puts(&quot;hi&quot;)</code></pre> <p> That’s an eyeful, but it’s mostly because paths are long and messy. Flag by flag:</p> <dl> <dt> <p> <code class="inline">-noshell</code> </p> </dt> <dd> <p> Skips starting the Erlang shell. We want this init flag if we’re working in Elixir and not Erlang. Either we don’t want a shell, or we want IEx. </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib</code> </p> </dt> <dd> <p> <code class="inline">-elixir_root</code> is a user flag. We’re telling the <code class="inline">init</code> to store the path to our installed Elixir <code class="inline">lib</code> dir under the key <code class="inline">:elixir_root</code>. </p> <p> Spoiler: The <code class="inline">start/2</code> function of the <code class="inline">elixir</code> module <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L40">uses</a> this stored value to set paths to <code class="inline">ebin</code> directories, where <code class="inline">.beam</code> files are. </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin</code> </p> </dt> <dd> <p> <code class="inline">-pa</code> is an init flag. Adds the path to the Elixir <code class="inline">.beam</code> files to Erlang’s code path. </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-elixir ansi_enabled true</code> </p> </dt> <dd> <p> This is that special <code class="inline">-&lt;application&gt; &lt;parameter&gt; &lt;value&gt;</code> user-flag format. Sets <code class="inline">:ansi_enabled</code> to <code class="inline">true</code> in the <code class="inline">:elixir</code> OTP application’s config when it starts. </p> </dd> </dl> <aside class="sidenote "> <p> As it happens, if I omit <code class="inline">-elixir ansi_enabled true</code>, it still shows up in the configuration for the <code class="inline">elixir</code> application. To convince myself that I can affect the config (and getting a little ahead of the plot), I can start up a BEAM instance just to configure and start Elixir, print the configuration, and shut down:</p> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir cat_food kibble \ -s elixir start_cli \ -extra -e &quot;IO.inspect(Application.get_all_env(:elixir))&quot;</code></pre> <p> and find in the output</p> <pre><code class="sh">cat_food: :kibble, ansi_enabled: true</code></pre> </aside> <dl> <dt> <p> <code class="inline">-s elixir start_cli</code> </p> </dt> <dd> <p> <code class="inline">-s</code> is another init flag. Run function <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L194"><code class="inline">start_cli/0</code></a> of the <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl"><code class="inline">elixir</code> module</a>. </p> <p> This function starts the <code class="inline">elixir</code> OTP <a href="https://www.erlang.org/doc/apps/kernel/application">application</a> (and starts the <code class="inline">logger</code> application) and finally passes our list of stored plain arguments to <code class="inline">Elixir.Kernel.CLI.main/1</code>, <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L23">“the API invoked by [the] Elixir boot process”</a> with this line: </p> <pre><code class="erlang"> &#39;Elixir.Kernel.CLI&#39;:main(init:get_plain_arguments()).</code></pre> <p> (Good thing we told Erlang where to find Elixir with the <code class="inline">-pa</code> flag.) </p> </dd> </dl> <dl> <dt> <p> <code class="inline">-extra -e IO.puts(&quot;hi&quot;)</code> </p> </dt> <dd> <p> Each thing after <code class="inline">-extra</code> in an <code class="inline">erl</code> expression is a plain argument, so <code class="inline">-e</code> and <code class="inline">&#39;IO.puts(&quot;hi&quot;)&#39;</code> are stored by the <code class="inline">init</code> as such. </p> <p> My <code class="inline">&#39;IO.puts(&quot;hi&quot;)&#39;</code> came out without its single quotes. I can roll with that; I had to type it in a way that would be parsed unambiguously in the shell, and now it’s in the shape it has to be in for the next thing to parse. </p> <p> On that topic, we can quickly check how the <code class="inline">init</code> stores plain arguments: </p> <pre><code class="sh">erl -extra -e &#39;IO.puts(&quot;hi&quot;)&#39; </code></pre> <pre><code>Erlang/OTP 27 [erts-15.2.1] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit] Eshell V15.2.1 (press Ctrl+G to abort, type help(). for help) 1&gt; init:get_plain_arguments(). [&quot;-e&quot;,&quot;IO.puts(\&quot;hi\&quot;)&quot;]</code></pre> <p> (Plain arguments keep their order in the list, which is important when it comes to parsing and using them.) </p> </dd> </dl> <p> Recapping what’s explicit in the <code class="inline">erl</code> expression: typing <code class="inline">elixir -e &#39;IO.puts(&quot;hi&quot;)&#39;</code> into my system shell starts an Erlang VM (BEAM) instance in which the Erlang <code class="inline">init</code> process:</p> <ul> <li> <em>doesn’t</em> start an Erlang shell </li> <li> prepares the Erlang runtime environment, including: <ul> <li> setting the path to Elixir <code class="inline">.beam</code> files </li> <li> storing some <code class="inline">arguments</code>, which in this case are for setting up the <code class="inline">elixir</code> OTP application </li> <li> storing some <code class="inline">plain_arguments</code> that correspond to the arguments I passed to the <code class="inline">elixir</code> command </li> </ul> </li> <li> invokes the <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L194"><code class="inline">start_cli/0</code></a> function of the <code class="inline">elixir</code> module </li> </ul> <p> That’s the end of what we can read on the face of the <code class="inline">erl</code> expression.</p> <p> Then, <code class="inline">elixir:start_cli/0</code> configures and starts the <code class="inline">elixir</code> and <code class="inline">logger</code> OTP applications, yoinks the list of plain arguments from the Erlang <code class="inline">init</code>, and passes that to our first Elixir function, <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex#L25"><code class="inline">Elixir.Kernel.CLI.main/1</code></a>. </p> <p> So I want to know what Elixir does with these arguments.</p> <div class="callout"> <h4> What Elixir does with the plain arguments</h4> <p> <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex#L25"><code class="inline">Elixir.Kernel.CLI.main/1</code></a> starts out with a <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex#L6">map of default config options</a> for its own internal use and the incoming <code class="inline">argv</code> list provided by <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L194"><code class="inline">elixir:start_cli/0</code></a>, and surfs <code class="inline">parse_argv/2</code> clauses, knocking arguments out of <code class="inline">argv</code> and modifying its <code class="inline">config</code> map as they match.</p> <p> The arguments must include something to run, or there’s no point to any of this. An argument preceded by a flag like <a href="https://github.com/elixir-lang/elixir/blob/69990a5d1d3cd00ed0422a87b49841c27e16ff15/lib/elixir/lib/kernel/cli.ex#L233"><code class="inline">&quot;-S&quot;</code></a> or <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L272"><code class="inline">&quot;-e&quot;</code></a>, or an argument that <a href="https://github.com/elixir-lang/elixir/blob/69990a5d1d3cd00ed0422a87b49841c27e16ff15/lib/elixir/lib/kernel/cli.ex#L381">hasn’t been otherwise recognised, and so is assumed to indicate a file</a>, is identified as a thing to run, and populates the <code class="inline">commands</code> list in the <code class="inline">config</code> map.</p> <p> What remains in <code class="inline">argv</code> once the <code class="inline">parse_argv</code> gauntlet is run <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L27">replaces</a> the <a href="https://hexdocs.pm/elixir/System.html"><code class="inline">System</code> “command line arguments” list</a> for whatever runs next, and <code class="inline">Kernel.CLI.main/1</code> turns its attention to executing its list of <code class="inline">commands</code>.</p> </div> <p> So <em>that’s</em> what <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/lib/kernel/cli.ex#L23">“the API invoked by [the] Elixir boot process”</a> meant. The options you pass to the <code class="inline">elixir</code> CLI command, telling it what you want “Elixir” to do, go to the <code class="inline">Kernel.CLI</code> Elixir module, which makes it happen.</p> <p> My request to <code class="inline">e</code>valuate the Elixir syntax <code class="inline">IO.puts(&quot;hi&quot;)</code> is executed. The VM prints <code class="inline">hi</code> to stdout. I see it in my terminal. Elixir has done what I asked and halts the system.</p> <h3> <code class="inline">mix</code></h3> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 mix </code></pre> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -s elixir start_cli \ -extra /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/mix</code></pre> <p> This is identical to the <code class="inline">elixir -e &#39;IO.puts(&quot;hi&quot;)&#39;</code> example, but with different plain arguments after the <code class="inline">-extra</code> flag.</p> <p> <code class="inline">Elixir.Kernel.CLI</code> will recognise the path to the <code class="inline">mix</code> script as the path to a file, read it, and call the function inside: <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/mix/lib/mix/cli.ex"><code class="inline">Mix.CLI.main()</code></a>.</p> <div class="callout"> <h3> By the way: these <code class="inline">erl</code> commands aren’t for us</h3> <p> Running <code class="inline">erl</code> commands from the shell does an end run around the Elixir installation and the environment setup it takes care of. </p> <p> It just so happens that I got away with running the simple <code class="inline">elixir</code> example by its <code class="inline">erl</code> equivalent, but trying the same with <code class="inline">mix</code> leaves me missing <code class="inline">MIX_HOME</code> and <code class="inline">MIX_ARCHIVES</code> environment variables, the initial symptom being that Mix doesn’t know where to find <a href="https://hex.pm/">Hex</a>. </p> </div> <h3> <code class="inline">iex</code></h3> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 iex </code></pre> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -user elixir \ -extra --no-halt +iex</code></pre> <p> In the not-IEx commands, <code class="inline">-s elixir start_cli</code> started Elixir, but the <code class="inline">-s</code> flag doesn’t show up here.</p> <dl> <dt> <p> <code class="inline">-user elixir</code> </p> </dt> <dd> <p> ELUSIVE. But important! <code class="inline">-user</code> is a user flag, and isn’t in the docs, but it’s a special one; the Erlang <code class="inline">user_sup</code> module <a href="https://github.com/erlang/otp/blob/maint-27/lib/kernel/src/user_sup.erl#L43">looks in the init arguments</a> for the key <code class="inline">user</code>. </p> <p> The <code class="inline">user</code> is the process that deals with the Erlang VM’s I/O; to interact with IEx, we need input and output to go through it. </p> <p> The best resource I’ve found for this Erlang <code class="inline">user</code> concept: <a href="https://ferd.ca/repl-a-bit-more-and-less-than-that.html"><em>REPL? A bit more (and less) than that</em></a> by Fred Hebert. (“If you want to change where the IO takes place, change the user process, and everything gets redirected.”) </p> <p> It looks like passing <code class="inline">-user elixir</code> means <a href="https://github.com/erlang/otp/blob/maint-27/lib/kernel/src/user_sup.erl#L102"><code class="inline">user_sup:start_user/3</code></a> calls <a href="https://www.erlang.org/doc/apps/erts/erlang#apply/3"><code class="inline">apply(elixir, start, [])</code></a>. </p> <p> In turn, <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/elixir.erl#L182"><code class="inline">elixir:start/0</code></a> passes <a href="https://github.com/erlang/otp/blob/b6ab3a385ec72e346a44807d53e2109a51cde613/lib/kernel/src/user_drv.erl#L145"><code class="inline">user_drv:start/2</code></a> <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/elixir/src/iex.erl#L48"><code class="inline">iex:shell/0</code></a> for its <code class="inline">initial_shell</code> argument and <code class="inline">iex:shell/0</code>, finally, calls <code class="inline">elixir:start_cli/0</code>, which feeds our plain arguments to <code class="inline">Kernel.CLI</code> to be acted on. </p> </dd> </dl> <aside class="sidenote rowspan-2 "> <p> The name of the <a href="https://hexdocs.pm/iex/IEx.html#module-the-user-switch-command">User switch command</a> now makes a lot more sense to me.</p> <p> Possibly <code class="inline">-user</code> isn’t documented among <a href="https://www.erlang.org/doc/apps/erts/erl_cmd.html#flags">defined <code class="inline">erl</code> flags</a> because to use it you’d have to implement your own <code class="inline">user</code>, which would put you beyond needing to look up the flag…?</p> <p> A notable commit (2012): <a href="https://github.com/elixir-lang/elixir/commit/678fafe7c13b5950c770ad16d77622a7d0ebc0f0">“Improve IEx by using the -user option (ht @yrashk)”</a></p> </aside> <dl> <dt> <p> <code class="inline">-extra --no-halt +iex</code> </p> </dt> <dd> <p> The plain arguments are <code class="inline">--no-halt</code> and <code class="inline">+iex</code>. </p> <p> We can find their significance in the Elixir <a href="https://github.com/elixir-lang/elixir/blob/661319329e667f18158001441ee2ec43a537998e/lib/elixir/lib/kernel/cli.ex"><code class="inline">Kernel.CLI</code> source</a>: </p> <ul> <li> <code class="inline">--no-halt</code> results in a <code class="inline">no_halt: true</code> entry in the <code class="inline">config</code> map, which results in the decision not to emit <code class="inline">System.halt(status)</code> after executing <code class="inline">commands</code>. </li> <li> <code class="inline">+iex</code> sets <code class="inline">mode: :iex</code> in <code class="inline">config</code>; this seems to be mainly used to decide how to deal with other flags like <code class="inline">-v</code> or <code class="inline">--version</code>, and <code class="inline">--dbg</code>. </li> </ul> </dd> </dl> <p> Differences from the <code class="inline">elixir</code> command: </p> <ul> <li> start the <code class="inline">iex</code> application after <code class="inline">elixir</code> </li> <li> send all VM I/O through <code class="inline">iex</code> </li> <li> don’t halt the system once <code class="inline">Kernel.CLI</code> has processed the plain arguments and taken any actions they ask for </li> </ul> <aside class="sidenote "> <p> The <code class="inline">elixir</code> application <a href="https://github.com/elixir-lang/elixir/tree/v1.18/lib/elixir/src">source</a> is written Erlang; <code class="inline">iex</code> <a href="https://github.com/elixir-lang/elixir/tree/v1.18/lib/iex/lib">source</a> is in Elixir.</p> </aside> <p> As we know, the end result is that I’m dropped into an IEx shell once all that’s done, and I can ask IEx to run moar Elixir.</p> <h2> What’s running in the VM?</h2> <p> Bare minimum, that is.</p> <p> Here are the started applications in my bare IEX shell.</p> <pre><code class="sh">iex -e &quot;IO.inspect(Application.started_applications)&quot;</code></pre> <pre><code class="sh">Erlang/OTP 27 [erts-15.2.1] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit] [ {:logger, ~c&quot;logger&quot;, ~c&quot;1.17.3&quot;}, {:iex, ~c&quot;iex&quot;, ~c&quot;1.17.3&quot;}, {:elixir, ~c&quot;elixir&quot;, ~c&quot;1.17.3&quot;}, {:compiler, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;8.5.4&quot;}, {:stdlib, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;6.2&quot;}, {:kernel, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;10.2.1&quot;} ] Interactive Elixir (1.17.3) - press Ctrl+C to exit (type h() ENTER for help) iex(1)&gt; </code></pre> <p> I haven’t run into the place that starts the <code class="inline">compiler</code> application, but I can wave my hands and say it makes sense that we’d need it; I might ask the VM to run something that hasn’t been compiled yet.</p> <p> I can compare the applications started in a VM that I spun up to run an Elixir function to list the applications started in it:</p> <pre><code class="sh">elixir -e &quot;IO.inspect(Application.started_applications)&quot;</code></pre> <pre><code class="sh">[ {:logger, ~c&quot;logger&quot;, ~c&quot;1.17.3&quot;}, {:elixir, ~c&quot;elixir&quot;, ~c&quot;1.17.3&quot;}, {:compiler, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;8.5.4&quot;}, {:stdlib, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;6.2&quot;}, {:kernel, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;10.2&quot;} ]</code></pre> <p> For fun, here’s one just for <code class="inline">erl</code>. Just <code class="inline">kernel</code> and <code class="inline">stdlib</code> in this VM:</p> <pre><code class="sh">erl -eval &#39;io:format(&quot;~p~n&quot;, [application:which_applications()]).&#39;</code></pre> <aside class="sidenote rowspan-2 "> <p> I totally got Claude (3.7 Sonnet, 27 Feb 2025) to write this snippet.</p> </aside> <pre><code class="sh">Erlang/OTP 27 [erts-15.2.1] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit] [{stdlib,&quot;ERTS CXC 138 10&quot;,&quot;6.2&quot;},{kernel,&quot;ERTS CXC 138 10&quot;,&quot;10.2.1&quot;}] Eshell V15.2.1 (press Ctrl+G to abort, type help(). for help) 1&gt; </code></pre> <h2> Putting the pieces together</h2> <p> When we start the BEAM with an <code class="inline">iex</code> command, all the VM’s I/O goes through IEx, and IEx implements the interactivity, including taking care of interpretation of Elixir expressions, or compilation of code, as necessary.</p> <p> All that’s left is to add <code class="inline">-S mix phx.server</code>:</p> <pre><code class="sh">ELIXIR_CLI_DRY_RUN=1 iex -S mix phx.server </code></pre> <pre><code class="sh">erl -noshell \ -elixir_root /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib \ -pa /Users/chris/.asdf/installs/elixir/1.17.3-otp-27/bin/../lib/elixir/ebin \ -elixir ansi_enabled true \ -user elixir \ -extra --no-halt +iex -S mix phx.server</code></pre> <p> No surprises. Just like <code class="inline">iex</code>, but with an additional <code class="inline">-S mix phx.server</code> after <code class="inline">-extra</code>. </p> <p> Check on the plain arguments:</p> <pre><code class="sh">iex(1)&gt; :init.get_plain_arguments() [~c&quot;--no-halt&quot;, ~c&quot;+iex&quot;, ~c&quot;-S&quot;, ~c&quot;mix&quot;, ~c&quot;phx.server&quot;]</code></pre> <h3> How does Mix get its arguments?</h3> <p> We already talked about how the <code class="inline">[&quot;-S&quot;, &quot;mix&quot;]</code> part of the arguments list means <code class="inline">Elixir.Kernel.CLI</code> will execute the <code class="inline">mix</code> script. </p> <p> And we kinda know that Mix has to see the <code class="inline">&quot;phx.server&quot;</code> argument, since that’s the Mix Task we’re trying to run. Let’s just put a tidy bow on how that happens: </p> <p> As soon as <code class="inline">Kernel.CLI.parse_argv/2</code> matches <code class="inline">&quot;-S&quot;</code>, it stashes the next argument as a <code class="inline">:script</code> into its list of <code class="inline">commands</code> to run, and quits looking for things to parse. Everything that’s left in the original arguments list stays in the system command-line arguments list (<code class="inline">System.argv/0</code>). In this case, <code class="inline">&quot;phx.server&quot;</code> is what’s left.</p> <p> On the Mix side, the contents of the <code class="inline">mix</code> script calls <a href="https://github.com/elixir-lang/elixir/blob/v1.18/lib/mix/lib/mix/cli.ex"><code class="inline">Mix.CLI.main/1</code></a>, which defaults to getting its argument list from <code class="inline">System.argv/0</code>. Voilà: <code class="inline">Mix.CLI.main([&quot;phx.server&quot;])</code>.</p> <aside class="sidenote "> <p> I just checked and I can start this blog’s dev server from an IEx prompt by typing exactly that: <code class="inline">Mix.CLI.main([&quot;phx.server&quot;])</code></p> </aside> <p> An analogous thing happens, also via <code class="inline">Kernel.CLI</code>, if we run <code class="inline">mix phx.server</code>, or <code class="inline">elixir -S mix phx.server</code>.</p> <p> The first thing that <code class="inline">Mix.CLI.main/1</code> does is start the Mix application with <a href="https://github.com/elixir-lang/elixir/blob/69990a5d1d3cd00ed0422a87b49841c27e16ff15/lib/mix/lib/mix.ex#L426"><code class="inline">Mix.start/0</code></a>—but I could go on like this forever. Let’s just agree that Mix is now going to run the <code class="inline">phx.server</code> task.</p> <h2> Why is it shaped like this?</h2> <p> I now <em>truly believe</em> that <code class="inline">iex -S mix phx.server</code> starts my Phoenix dev server on a fresh Erlang VM and drops me into an Elixir shell in that VM.</p> <p> I’ve had the chance to admire the effort and ingenuity that goes into letting users run programs—no—<em>start up VMs and</em> run programs on them—with simple one-liners. </p> <p> I still go back and forth between “this is an obvious command that’s really explicit about what it does” and “something about this feels magical and weird.” That <code class="inline">-S</code> just sits kinda funny.</p> <p> If I were in the habit of using <code class="inline">elixir -S mix phx.server</code> to run the <code class="inline">phx.server</code> Mix task (which works): look, symmetry! <code class="inline">iex -S mix phx.server</code> is the same thing but through IEx!</p> <p> But I don’t do that, because <code class="inline">mix phx.server</code> works, thanks to <code class="inline">mix</code> being an Elixir script you can also invoke from a system shell. It all makes sense! Not so symmetric, though.</p> <p> In the end, it’s a balance between elegance and power. I see a lot more elegance in it than I did before.</p> <h2> Trivia: Some history of <code class="inline">iex -S mix</code></h2> <p> Early on, it seems there was some tension between the conciseness of <code class="inline">mix iex</code> (possible when <code class="inline">mix</code> is a plain shell script) and the flexibility of <code class="inline">iex -S mix</code> (possible when <code class="inline">mix</code> is an Elixir script); <code class="inline">bin/mix</code> went back and forth between shell script and Elixir script in 2012-2013: </p> <aside class="sidenote "> <p> Hat tip to <a href="https://elixirforum.com/t/where-to-find-info-about-iex-s-mix-command/48045/4"><code class="inline">@adamu</code> on the Elixir Forum</a>.</p> </aside> <ul> <li> 2012/07/16: <a href="https://github.com/elixir-lang/elixir/commit/a5a2025daf54f4a414ebcc1ba9949b7832b1b12d">“Add mix file executables”</a> (a shell script) </li> <li> 2012/07/31: <a href="https://github.com/elixir-lang/elixir/commit/05e52f9437d692c4fc8dc1b731574bbeeadc6fc6">“Make mix an Elixir script”</a> (an Elixir script) </li> <li> 2012/11/30: <a href="https://github.com/elixir-lang/elixir/commit/b3d203712a82fb02fc39016e42deba145825a856">“Fix mix iex”</a> (a shell script again) </li> <li> 2012/12/05: J. Valim: “I believe we need to remove support for <code class="inline">mix iex</code> as it needs to be <code class="inline">iex -S mix</code>.” (<a href="https://github.com/elixir-lang/elixir/issues/692">v0.7.2 breaks mix #692</a>; some discussion here.) </li> <li> 2013/01/20: <a href="https://github.com/elixir-lang/elixir/commit/aa9c93305ec27fa22a81b46a92ac7c9a985a8b30">“Provide iex -S mix instead of mix iex”</a> (an Elixir script again) </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/lagan/resources-erlang-otp/</id>
    <title>Erlang and OTP resources</title>
    <updated>2025-02-22T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/lagan/resources-erlang-otp/"/>
    <content type="html"><![CDATA[<p> <a href="https://www.erlang.org/doc/readme.html">Erlang docs home</a></p> <p> <a href="https://www.erlang.org/doc/system/design_principles.html">OTP design principles</a> - Supervision trees, behaviours, applications, releases, release handling</p> <p> <a href="https://learnyousomeerlang.com/">Learn you some Erlang for great good</a> - the classic by Fred Hebert</p> <p> <a href="https://www.erlang.org/blog">The OTP team blog</a> - good resource on how some things work</p>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/posts/2025-01-30-observer-elixir/</id>
    <title>Running Observer in IEx alongside an Elixir app</title>
    <updated>2025-01-30T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/posts/2025-01-30-observer-elixir/"/>
    <content type="html"><![CDATA[<p> I wanted to try out Erlang’s <a href="https://www.erlang.org/doc/apps/observer/observer_ug.html">Observer</a> application to dig into the workings of my Elixir/Phoenix dev server. It didn’t immediately work, for two main reasons:</p> <ol> <li> Observer’s graphical interface depends on both the <a href="https://www.wxwidgets.org/">wxWidgets</a> cross-platform GUI library and the OTP application <a href="https://www.erlang.org/doc/apps/wx/chapter.html">wx</a>, which supplies Erlang bindings for it. My system had neither. </li> <li> Once I’d sorted out the system problems in 1., I was able to run Observer from a plain IEx prompt, but not from the prompt opened with <code class="inline">iex -S mix phx.server</code>. To understand this, I had to learn that Elixir “prunes unused code paths.” More about this later. </li> </ol> <p> Getting past these roadblocks turned out pretty straightforward with the latest Erlang/OTP and a newish Elixir on my M2 Macbook in January 2025. I say <em>turned out</em>, because past discussions on issues around asdf, Erlang and wxWidgets had me ready for a big mess, and it took me a bit to isolate what was relevant to me.</p> <aside class="sidenote "> <p> For example: <a href="https://github.com/asdf-vm/asdf-erlang/issues/319">A late-2024 issue and discussion on the <code class="inline">asdf-erlang</code> GitHub repo</a>; <a href="https://elixirforum.com/t/observer-in-iex-s-mix-error-undefinedfunctionerror-function-wx-object-start-3-is-undefined/58544">a 2023-2024 topic on the Elixir Forum</a>.</p> <p> It’s possible that some of the complications folks have brought up with XCode or <code class="inline">ulimit</code> are still relevant; they just didn’t come up for me.</p> </aside> <p> Incidentally, I think everything here also applies to Erlang’s <a href="https://www.erlang.org/doc/apps/debugger/debugger_chapter.html">debugger</a> application, which also uses wxWidgets.</p> <h2> Sorting out my system</h2> <h3> Install wxWidgets</h3> <p> To begin with, I didn’t even have wxWidgets installed on my computer. I installed it with Homebrew: </p> <pre><code class="bash">brew install wxwidgets</code></pre> <h3> Install Erlang with wx enabled</h3> <p> I was still missing the <a href="https://www.erlang.org/doc/apps/wx/chapter.html">wx</a> OTP application; it had been disabled in my existing Erlang installation.</p> <p> I manage runtimes on my Mac with <a href="https://asdf-vm.com/guide/introduction.html">asdf</a>. I suspect that I could have simply uninstalled and reinstalled Erlang after putting wxWidgets on my system, but I included wx explicitly, as follows:</p> <pre><code class="sh">export KERL_CONFIGURE_OPTIONS=&quot;--with-wx&quot; asdf install erlang 27.2</code></pre> <aside class="sidenote rowspan-2 "> <p> The <a href="https://github.com/asdf-vm/asdf-erlang">asdf Erlang plugin</a> uses <a href="https://github.com/kerl/kerl"><code class="inline">kerl</code></a> to build Erlang. Setting the <code class="inline">KERL_CONFIGURE_OPTIONS</code> environment variable to <code class="inline">&quot;--with-wx&quot;</code> makes sure <code class="inline">kerl</code> includes wx.</p> </aside> <p> The conservative thing would have been to uninstall the current Erlang and reinstall the same version but with wx enabled, but I went ahead and updated from 26.0.1 to 27.2. </p> <p> Because I changed versions, I put the correct version in my project’s <a href="https://asdf-vm.com/manage/configuration.html#tool-versions"><code class="inline">.tool-versions</code></a> file with <a href="https://asdf-vm.com/guide/getting-started.html#local"><code class="inline">asdf local</code></a>. Because I changed <em>major</em> versions, I also had to install an Elixir compiled with the right Erlang/OTP, and set the local version of that as well.</p> <aside class="sidenote "> <p> Related: <a href="2025-01-29-asdf-switch-erlang">My personal cheat sheet for the mechanics of changing Erlang versions with asdf</a></p> </aside> <h3> Check that wx and Observer work</h3> <p> At this point I was able to fire up IEx with <code class="inline">iex</code> and type </p> <pre><code class="makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="nc">:observer</span><span class="o">.</span><span class="n">start</span><span class="p" data-group-id="8397203090-1">(</span><span class="p" data-group-id="8397203090-1">)</span></code></pre> <p> and the Observer GUI popped up. Under the Applications tab were listed just <code class="inline">elixir</code>, <code class="inline">iex</code>, <code class="inline">kernel</code>, and <code class="inline">logger</code>.</p> <p> There’s also the <a href="https://www.erlang.org/doc/apps/wx/wx.html#demo/0">wx demo</a>. Since I’d seen Observer working in IEx, I didn’t need to check wx by itself, but it’s a thing if you do need it or want to try it. Start up the Erlang shell:</p> <pre><code class="sh">erl</code></pre> <p> And run the demo:</p> <pre><code class="erlang">&gt; wx:demo().</code></pre> <p> A demo GUI should open, proving that wxWidgets and its Erlang bindings are present and working.</p> <h2> The deal with code-path pruning</h2> <p> <a href="https://elixirforum.com/t/elixir-v1-15-0-released/56584">As of Elixir 1.15, before a Mix project gets compiled, “unused code paths” are pruned</a>, including for applications that ship with Elixir or Erlang, like Observer. </p> <p> Translation: the Erlang runtime will look for modules in only directories containing the project’s dependencies. This makes compilation faster.</p> <p> So, a general-purpose IEx prompt has access to all the stuff that comes with your Elixir and Erlang installations, but use <code class="inline">iex -S</code> to run a Mix task, and any module that is not used in that Mix project becomes invisible.</p> <h3> Including Observer and its dependencies</h3> <p> You can declare a dependency on an OTP application in <code class="inline">mix.exs</code> by <a href="https://hexdocs.pm/mix/1.18.2/Mix.Tasks.Compile.App.html">including it in an <code class="inline">application/0</code> function, under <code class="inline">:extra_applications</code></a>. My understanding is that this is meant for applications shipped with Erlang/OTP or Elixir—everything else you’d just put in your <code class="inline">deps</code> definition. </p> <aside class="sidenote rowspan-1 "> <p> Trivia: according to its <a href="https://hexdocs.pm/mix/1.18.2/Mix.Tasks.Compile.App.html">documentation</a>, Mix makes sure applications in <code class="inline">:extra_applications</code> are started before the project application—with the exception of applications declared <code class="inline">:optional</code>. </p> </aside> <p> If you don’t always need a given application in the project, you can instead make it available from the prompt on a one-off basis. Without putting anything into my <code class="inline">:extra_applications</code>, under OTP 27, I can start my dev server: </p> <pre><code class="sh">iex -S mix phx.server</code></pre> <p> Then restore the code path to Observer in IEX with <a href="https://hexdocs.pm/mix/1.18.2/Mix.html#ensure_application!/1"><code class="inline">Mix.ensure_application!(app)</code></a>:</p> <pre><code class="makeup elixir"><span class="gp unselectable">iex(1)&gt; </span><span class="nc">Mix</span><span class="o">.</span><span class="n">ensure_application!</span><span class="p" data-group-id="6184114132-1">(</span><span class="ss">:observer</span><span class="p" data-group-id="6184114132-1">)</span></code></pre> <aside class="sidenote "> <p> It seems that <code class="inline">Mix.ensure_application!/1</code> goes ahead and pulls in an application’s optional dependencies in a way that adding it to <code class="inline">:extra_applications</code> doesn’t:</p> <blockquote> <p> You need to add <code class="inline">:wx</code> to extra applications because it is an optional dependency of <code class="inline">:observer</code>. The <code class="inline">ensure_application!</code> also considers optional dependencies. </p> <p> – <em><a href="https://elixirforum.com/t/observer-in-iex-s-mix-error-undefinedfunctionerror-function-wx-object-start-3-is-undefined/58544/10">José Valim on the Elixir Forum</a></em> </p> </blockquote> </aside> <p> Finally, start Observer:</p> <pre><code class="makeup elixir"><span class="gp unselectable">iex(2)&gt; </span><span class="nc">:observer</span><span class="o">.</span><span class="n">start</span><span class="p" data-group-id="9330854025-1">(</span><span class="p" data-group-id="9330854025-1">)</span></code></pre> <p> Up pops the Observer GUI. A quick check of the Applications tab shows the application supervision tree for my running project. </p> <h2> Other notes</h2> <p> It looks like the way dependencies, and thus “unused code paths” to be pruned, are decided has been streamlined between OTP 26 and OTP 27.</p> <p> Under Erlang/OTP 26, I had to explicitly require <code class="inline">:wx</code> and <code class="inline">:runtime_tools</code> as well as <code class="inline">:observer</code> in order to run Observer. With OTP 27 I only had to ensure <code class="inline">:observer</code>, even after removing the <code class="inline">:extra_applications</code> keyword entirely from the <code class="inline">application</code> definition in my <code class="inline">mix.exs</code>. </p> <p> I see that <code class="inline">:observer_backend</code> is part of <code class="inline">:runtime_tools</code>. I’m keeping that in mind in case I need to understand this when I try to look at production nodes from my laptop.</p>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/elixir/2025-01-29-asdf-switch-erlang/</id>
    <title>Switching an Elixir project between Erlang/OTP major versions with asdf</title>
    <updated>2025-01-29T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/elixir/2025-01-29-asdf-switch-erlang/"/>
    <content type="html"><![CDATA[<h2> Assumptions</h2> <p> We manage runtimes with <a href="https://asdf-vm.com">asdf</a>. In this example we’re using Elixir 1.17.3 in a project and want to switch from <a href="https://github.com/erlang/otp">OTP</a> 26.2.5.6 to OTP 27.2.</p> <h2> Steps</h2> <h3> 0. Check the status quo</h3> <p> See which versions of any installed runtimes, including Elixir and Erlang/OTP, are set for the current directory, and see if that’s through the global <code class="inline">.tool-versions</code> config file or a local one:</p> <pre><code class="sh">asdf current</code></pre> <p> See which versions of Erlang/OTP are installed on the system with asdf:</p> <pre><code class="sh">asdf list elixir</code></pre> <pre><code class="sh">asdf list erlang</code></pre> <h3> 1. Install the new Erlang/OTP</h3> <pre><code class="sh">asdf install erlang 27.2</code></pre> <h3> 2. Install an Elixir version compiled with the right OTP major version</h3> <p> Even if we don’t want to upgrade Elixir versions per se, we do need to match the Elixir installation with our OTP major version.</p> <pre><code class="sh">asdf install elixir 1.17.3-otp-27 </code></pre> <h3> 3. Set the project to use the newly installed versions of both</h3> <pre><code class="sh">asdf local elixir 1.17.3-otp-27</code></pre> <pre><code class="sh">asdf local erlang 27.2</code></pre> <p> Now asdf is configured to point to the newly installed version of Erlang/OTP and the Elixir version that’s compatible with it. </p> <aside class="sidenote "> <p> You can edit <code class="inline">.tool-versions</code> directly, but If you don’t know which version you need, <code class="inline">asdf local</code> (and <code class="inline">asdf global</code>) conveniently shows you the possible versions if you hit the <code class="inline">tab</code> key.</p> </aside> <h2> References</h2> <ul> <li> <a href="https://asdf-vm.com/guide/introduction.html">asdf guide introduction</a> </li> <li> <a href="https://asdf-vm.com/manage/configuration.html">asdf configuration (<code class="inline">.tool-versions</code>)</a> </li> <li> <a href="https://github.com/asdf-vm/asdf-erlang">asdf Erlang plugin</a> </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/lagan/2025-01-12-tailwind-wrong-way/</id>
    <title>Using Tailwind CSS the wrong way</title>
    <updated>2025-01-13T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/lagan/2025-01-12-tailwind-wrong-way/"/>
    <content type="html"><![CDATA[<p> I was in the midst of power-washing <a href="https://tailwindcss.com/">Tailwind</a> classes off of a Phoenix component (for reasons) when Xe Iaso posted this: <a href="https://xeiaso.net/blog/2025/tailwind-sans-bloat/">CSSWind: bloat-free component styling</a>. Here’s my (unironic) opportunistic tie-in.</p> <p> I’m persistently perturbed by HTML festooned with utility classes. But Tailwind presets tangibly save me typing time and decision-making time, and they’re easy to remember.</p> <aside class="sidenote rowspan-1 "> <p> Yay constraints!</p> </aside> <p> What I’ve found myself doing, increasingly, is giving elements more-or-less semantic classes and hiding the styling away in <code class="inline">.css</code> files where, also increasingly, I use Tailwind’s <code class="inline">@apply</code> directive to put Tailwind classes in place of CSS.</p> <p> It all comes out in the wash when Tailwind spits out a file full of regular CSS.</p> <p> <a href="https://tailwindcss.com/docs/reusing-styles">This would seem to be an official anti-pattern</a>, and I’ll entertain the thought that it may just be a stubborn lone-developer habit. I’m wearing my stubborn lone-developer hat at the moment, so until I grow out of it, I think it’s cool that Tailwind itself doesn’t judge me for it.</p> <aside class="sidenote rowspan-1 "> <p> I’ve decided to infer that though <em>people</em> may judge, Tailwind is tacitly cool with it because it doesn’t throw any speed bumps in my way.</p> </aside> <h2> An example</h2> <p> In:</p> <pre><code class="css">div.annotated-content-container { @apply grid grid-cols-[4fr_3fr] col-span-full rounded-lg mb-6 bg-zinc-100; background: linear-gradient(to right, rgba(241, 245, 249, 1) 57%, rgba(241, 245, 249, 0) 43%); } .annotated-content { @apply w-full items-start rounded-lg border border-slate-300 py-4; } .subgrid-holder { @apply grid grid-cols-subgrid col-span-full; }</code></pre> <p> Out:</p> <pre><code class="css">div.annotated-content-container { grid-column: 1 / -1; margin-bottom: 1.5rem; display: grid; grid-template-columns: 4fr 3fr; border-radius: 0.5rem; --tw-bg-opacity: 1; background-color: rgb(244 244 245 / var(--tw-bg-opacity)); background: linear-gradient(to right, rgba(241, 245, 249, 1) 57%, rgba(241, 245, 249, 0) 43%); } .annotated-content { width: 100%; align-items: flex-start; border-radius: 0.5rem; border-width: 1px; --tw-border-opacity: 1; border-color: rgb(203 213 225 / var(--tw-border-opacity)); padding-top: 1rem; padding-bottom: 1rem; } .subgrid-holder { grid-column: 1 / -1; display: grid; grid-template-columns: subgrid; }</code></pre> <aside class="sidenote "> <p> If I were really finicky about bloat (in my CSS) I’d find a way to process out the variables. Some Elixir in my project would likely beat PostCSS for convenience, since Phoenix’s very plush asset processing uses the standalone Tailwind binary. Related: <a href="https://github.com/tailwindlabs/tailwindcss/issues/15136">v4 larger base output #15136</a> </p> </aside>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/elixir/2024-12-31-js-in-phoenix/</id>
    <title>Adding custom JavaScript to a Phoenix app</title>
    <updated>2024-12-31T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/elixir/2024-12-31-js-in-phoenix/"/>
    <content type="html"><![CDATA[<p> Out of the box, the Phoenix <a href="https://hexdocs.pm/phoenix/asset_management.html">asset build system</a> bundles custom JS alongside default Phoenix JS dependencies, using <a href="https://esbuild.github.io/">esbuild</a>, into a script that the app serves with all its pages.</p> <aside class="sidenote rowspan-2 "> <p> CSS is dealt with in an analogous way, using <a href="https://tailwindcss.com/">tailwindcss</a>.</p> </aside> <p> I was braced for this to be much more complicated than it is.</p> <p> Basic usage is described in the comments at the top of <code class="inline">assets/js/app.js</code>. To paraphrase, with a little colour:</p> <ul> <li> The convention is to put source files for front-end assets into your app’s <a href="https://hexdocs.pm/phoenix/directory_structure.html#the-assets-directory"><code class="inline">assets</code> directory</a>. The suggested location for third-party JS files is <code class="inline">assets/vendor</code>, and for LiveView hooks it’s <code class="inline">assets/js/hooks</code>. </li> <li> In <code class="inline">assets/js/app.js</code>: <ul> <li> <code class="inline">import</code> the new JS files—or one file that <code class="inline">imports</code> its own dependencies. </li> <li> Add any calls to imported JS functions that should be executed when the browser loads a page. </li> </ul> </li> </ul> <p> When the project’s assets are built, esbuild bundles the contents of <code class="inline">assets/js/app.js</code> and its <code class="inline">import</code>ed dependencies (and their dependencies, recursively) into <code class="inline">priv/static/assets/app.js</code> where it’s available to be served as a static asset. </p> <p> Assets get built either by a watcher on the running dev server or by a Mix task. When the server starts in dev mode, it, in turn, starts an esbuild process in watch mode that builds and rebuilds the JS bundle as its source files change.</p> <p> The <code class="inline">assets.build</code> and <code class="inline">assets.deploy</code> <a href="https://hexdocs.pm/mix/Mix.html#module-aliases">Mix aliases</a> include an <code class="inline">esbuild</code> Mix task to build JS assets (<code class="inline">assets.deploy</code> minifies them as well).</p> <p> The bundled <code class="inline">priv/static/assets/app.js</code> is served at <code class="inline">/assets/app.js</code> and sourced in <code class="inline">&lt;script&gt;</code> tags in the app’s root layout, so that it runs when the browser loads a page.</p> <h2> Building blocks</h2> <p> Chris McCord’s <a href="https://gist.github.com/chrismccord/2ab350f154235ad4a4d0f4de6decba7b#migrate-to-esbuild-for-js-and-css-bundling-optional">gist on upgrading from Phoenix v1.5 to v1.6</a> illuminates the moving parts of the esbuild-based system that come with a freshly generated Phoenix app.</p> <h3> The esbuild Hex package</h3> <p> An <a href="https://github.com/phoenixframework/esbuild/">Elixir wrapper for esbuild</a> that provides the Esbuild module and Mix tasks to install and run esbuild.</p> <h3> config.exs</h3> <p> Contains a configuration entry for the esbuild wrapper, with a named <a href="https://github.com/phoenixframework/esbuild/tree/main?tab=readme-ov-file#profiles">execution profile</a> that gives a set of args and options common to all out-of-the-box esbuild invocations in the app.</p> <aside class="sidenote rowspan-2 "> <p> You can define multiple profiles if you want to generate different bundles.</p> </aside> <p> This profile sets <code class="inline">assets/js/app.js</code> as the entry point and <code class="inline">priv/static/assets</code> as the output directory to pass to esbuild.</p> <h3> mix.exs</h3> <p> Includes the <code class="inline">esbuild</code> Hex package in the project dependencies; it’s only part of the runtime in a development environment.</p> <p> Defines Mix <a href="https://hexdocs.pm/mix/Mix.html#module-aliases">aliases</a> <code class="inline">assets.build</code> and <code class="inline">assets.deploy</code> that run the <code class="inline">esbuild</code> Mix task with the execution profile from <code class="inline">config.exs</code>.</p> <h3> dev.exs</h3> <p> Contains the dev-environment-only configuration for the app’s <code class="inline">Endpoint</code> module. Configures a “watcher” that calls the <code class="inline">Esbuild.install_and_run</code> function to start esbuild, in watch mode, again with the profile defined in <code class="inline">config.exs</code>.</p> <aside class="sidenote rowspan-2 "> <p> <code class="inline">:watchers</code> is part of the app’s <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#module-runtime-configuration">Endpoint’s runtime configuration</a>. A watcher here is an executable that starts when the server starts—it’s a slightly misleading name because “watching” behaviour has to be supplied by the executable itself.</p> </aside> <h3> root.html.heex</h3> <p> The app’s root layout. Sources the bundled JS assets with <code class="inline">&lt;script&gt;</code> tags.</p> <h3> router.ex</h3> <p> Following this even further: the app’s Router module includes the <code class="inline">browser</code> pipeline, where the <code class="inline">put_root_layout</code> plug incorporates <code class="inline">root.html.heex</code>, and thus the app’s bundled <code class="inline">app.js</code>, into every page that gets piped through the <code class="inline">browser</code> pipeline.</p> <aside class="sidenote "> <p> Root layout: <code class="inline">lib/your_app_web/components/layouts/root.html.heex</code>. Embedded by the app’s <code class="inline">Layouts</code> module.</p> </aside> <h2> Or</h2> <p> Nothing stops you from adding your own <code class="inline">&lt;script&gt;</code> tags, in the app’s root layout or somewhere else, pointing to some script that a user’s browser can reach: a location on the net, or a file your app serves with a <code class="inline">Static</code> plug.</p> <p> Taking that further, you could tweak the out-of-the-box Phoenix asset management system to generate another custom bundle and reference that script from only certain layouts or pages.</p> <h2> References</h2> <ul> <li> <a href="https://hexdocs.pm/phoenix/asset_management.html#third-party-js-packages">Asset management: Third-party JS packages</a> (Phoenix docs) </li> <li> <a href="https://hexdocs.pm/phoenix/directory_structure.html#the-assets-directory">The assets directory</a> (Phoenix docs) </li> <li> <a href="https://gist.github.com/chrismccord/2ab350f154235ad4a4d0f4de6decba7b">Chris McCord’s gist on upgrading to Phoenix 1.6</a> (shows how to manually configure an app for esbuild instead of webpack) </li> <li> <a href="https://github.com/phoenixframework/esbuild/">Elixir wrapper for esbuild</a> (GitHub repo) </li> <li> <a href="https://hexdocs.pm/mix/Mix.html#module-aliases">Aliases</a> (Mix docs) </li> <li> <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#module-runtime-configuration">Phoenix.Endpoint module runtime configuration</a> (with watcher config) (Phoenix docs) </li> <li> <a href="https://hexdocs.pm/elixir/Config.html">Config API</a> (Elixir docs) </li> <li> <a href="https://hexdocs.pm/phoenix/Phoenix.Router.html#module-pipelines-and-plugs">Pipelines and plugs</a> (Phoenix docs) </li> </ul>]]></content>
  </entry>
  <entry>
    <id>https://clutterstack.com/particles/elixir/2024-10-26-elixir-plug-static-paths/</id>
    <title>Custom paths for static assets in a Phoenix app</title>
    <updated>2024-10-26T00:00:00.000Z</updated>
    <link rel="alternate" href="https://clutterstack.com/particles/elixir/2024-10-26-elixir-plug-static-paths/"/>
    <content type="html"><![CDATA[<p> TIL you can use multiple <a href="https://hexdocs.pm/plug/Plug.Static.html"><code class="inline">Static</code> plugs</a> to serve static files at custom paths in an Elixir / Phoenix app.</p> <p> I used this to specify the path at which my sitemap files are served without affecting any other static assets.</p> <p> In a project created with <code class="inline">mix phx.new</code>, the <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html">Endpoint</a> module sets out a initial plug pipeline that all requests go through. (It ends with <code class="inline">plug YourAppWeb.Router</code>, passing the request off to your app’s Phoenix <a href="https://hexdocs.pm/phoenix/Phoenix.Router.html">Router</a> module, which decides which pipeline it should go through next.)</p> <p> Requests pass through <a href="https://hexdocs.pm/plug/Plug.Static.html"><code class="inline">Plug.Static</code></a> early on; if the request path matches a path in the app’s <code class="inline">priv/static/</code> directory, it serves the file directly.</p> <p> Here’s mine:</p> <pre><code class="makeup elixir"><span class="w"> </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Static</span><span class="p">,</span><span class="w"> </span><span class="ss">at</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">from</span><span class="p">:</span><span class="w"> </span><span class="ss">:clutterstack</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="nc">ClutterstackWeb</span><span class="o">.</span><span class="n">static_paths</span><span class="p" data-group-id="0847884981-1">(</span><span class="p" data-group-id="0847884981-1">)</span></code></pre> <p> By default, everything in <code class="inline">priv/static/</code> is served at a URL that reflects the file’s path relative to that directory. The <code class="inline">only: YourAppWeb.static_paths()</code> option narrows that down to a list of folders and files.</p> <p> The <code class="inline">:only</code> option also saves unnecessary file system reads: the request URI is checked against this list first, so if the requested path isn’t included, there’s no need to check inside <code class="inline">priv/static/</code> for the presence of the file.</p> <p> For fun, let’s just look at where that list is defined. Here’s <code class="inline">static_paths</code> from my <code class="inline">clutterstack_web.ex</code> file:</p> <aside class="sidenote rowspan-7 "> <p> I refer to modules by their filenames sometimes. It was helpful for me to realise, though, that while Phoenix has conventions for module filenames and directories, it’s the module name and definition inside the file that’s important. You can organize modules in their <code class="inline">.ex</code> files how you like.</p> <p> When I was starting out, I didn’t get this, and worried way too much about where to put module files and what to call them.</p> <p> (This doesn’t go for <code class="inline">.exs</code> files, which are definitely referred to by their locations and filenames.)</p> </aside> <pre><code class="makeup elixir"><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="nf">static_paths</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="sx">~w(assets fonts images favicon.ico robots.txt)</span></code></pre> <p> (The <a href="https://hexdocs.pm/elixir/sigils.html#word-lists"><code class="inline">~w</code> sigil</a> converts space-separated words into a list of strings.)</p> <p> So <code class="inline">priv/static/robots.txt</code> gets served at <code class="inline">/robots.txt</code> and images at, e.g. <code class="inline">/images/whatever.jpg</code>.</p> <p> I have also have sitemap files inside <code class="inline">priv/static/sitemaps/</code>. If I include <code class="inline">sitemaps</code> in the above <code class="inline">:only</code> option, these files will be served at <code class="inline">/sitemaps/sitemapfile.xml</code>. I’d prefer to use the root path where indexers look by default: <code class="inline">https://clutterstack.com/sitemap.xml</code>.</p> <p> So I added another static plug to <code class="inline">endpoint.ex</code> just for sitemaps:</p> <pre><code class="makeup elixir"><span class="w"> </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Static</span><span class="p">,</span><span class="w"> </span><span class="ss">at</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">from</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0825008546-1">{</span><span class="ss">:clutterstack</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;priv/static/sitemaps/&quot;</span><span class="p" data-group-id="0825008546-1">}</span></code></pre> <p> Bob’s your uncle; all my sitemap files are served at the root path. </p> <p> This wasn’t the only solution to making my sitemap easy for robots to find; <a href="https://developers.google.com/search/docs/crawling-indexing/robots/create-robots-txt">you can also specify a non-default location of a sitemap file in <code class="inline">robots.txt</code></a> (developers.google.com). </p>]]></content>
  </entry>
</feed>